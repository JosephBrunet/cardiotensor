{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"Cardiotensor <p>A Python package for calculating 3D cardiomyocyte orientations in heart images.</p> <p> </p> <p> Helical angle map of a heart scanned using synchrtron X-ray imaging. </p>"},{"location":"#introduction","title":"Introduction","text":"<p>Cardiotensor is a user-friendly and memory-efficient toolkit designed for analyzing the orientation of cardiomyocyte fibers in large heart imaging datasets. It uses advanced image processing techniques to help researchers to accurately quantify 3D cardiomyocyte orientations with high efficiency.</p>"},{"location":"#installation","title":"Installation","text":"<p>Clone the repository and install the package using pip:</p> <pre><code>git clone https://github.com/JosephBrunet/cardiotensor.git\ncd cardiotensor\npip install .\n</code></pre> <p>\u26a0\ufe0f Require python 3.10 or newer</p>"},{"location":"#documentation","title":"Documentation","text":"<p>cardiotensor's documentation is available at josephbrunet.fr/cardiotensor/</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Have a look at our simple example that runs you through all the commands of the package</p>"},{"location":"#more-information","title":"More Information","text":"<p>This package uses the structure-tensor package to calculate the structure tensor, extending its capabilities for cardiac imaging.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! If you encounter a bug or have suggestions for new features:</p> <ul> <li>Report an Issue: Open an issue in the repository.</li> <li>Submit a Pull Request: Fork the repository, make changes, and submit a pull request.</li> </ul> <p>For major changes, please discuss them in an issue first.</p>"},{"location":"#contact","title":"Contact","text":"<p>For questions, feedback, or support, please contact the maintainers at [j.brunet@ucl.ac.uk].</p>"},{"location":"#reference","title":"Reference","text":"<p>Brunet, J., Cook, A. C., Walsh, C. L., Cranley, J., Tafforeau, P., Engel, K., Arthurs, O., Berruyer, C., Burke O\u2019Leary, E., Bellier, A., et al. (2024). Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography. Radiology, 312(1), e232731. https://doi.org/10.1148/radiol.232731. [PDF]</p> <pre><code>@article{brunet2024multidimensional,\n  title={Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography},\n  author={Brunet, Joseph and Cook, Andrew C and Walsh, Claire L and Cranley, James and Tafforeau, Paul and Engel, Klaus and Arthurs, Owen and Berruyer, Camille and Burke O\u2019Leary, Emer and Bellier, Alexandre and others},\n  journal={Radiology},\n  volume={312},\n  number={1},\n  pages={e232731},\n  year={2024},\n  publisher={Radiological Society of North America}\n}\n</code></pre>"},{"location":"citing/","title":"Citing","text":"<p>If you use <code>cardiotensor</code> in your research, please cite the related paper as follow:</p>"},{"location":"citing/#apa-format","title":"APA Format","text":"<p>Brunet, J., Cook, A. C., Walsh, C. L., Cranley, J., Tafforeau, P., Engel, K., Arthurs, O., Berruyer, C., Burke O\u2019Leary, E., Bellier, A., et al. (2024). Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography. Radiology, 312(1), e232731. https://doi.org/10.1148/radiol.232731</p>"},{"location":"citing/#bibtex-format","title":"BibTeX Format","text":"<p>For LaTeX users, please include the following BibTeX entry to reference <code>cardiotensor</code>:</p> <pre><code>@article{brunet2024multidimensional,\n  title={Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography},\n  author={Brunet, Joseph and Cook, Andrew C and Walsh, Claire L and Cranley, James and Tafforeau, Paul and Engel, Klaus and Arthurs, Owen and Berruyer, Camille and Burke O\u2019Leary, Emer and Bellier, Alexandre and others},\n  journal={Radiology},\n  volume={312},\n  number={1},\n  pages={e232731},\n  year={2024},\n  publisher={Radiological Society of North America}\n}\n</code></pre>"},{"location":"citing/#citation-examples-in-various-formats","title":"Citation Examples in Various Formats","text":"<ol> <li> <p>MLA Format    Brunet, Joseph, et al. \"Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography.\" Radiology, vol. 312, no. 1, 2024, p. e232731.</p> </li> <li> <p>Chicago Style    Brunet, Joseph, Andrew C. Cook, Claire L. Walsh, James Cranley, Paul Tafforeau, Klaus Engel, Owen Arthurs, Camille Berruyer, Emer Burke O\u2019Leary, Alexandre Bellier, et al. 2024. \"Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography.\" Radiology 312 (1): e232731.</p> </li> <li> <p>Harvard Format    Brunet, J., Cook, A.C., Walsh, C.L., Cranley, J., Tafforeau, P., Engel, K., Arthurs, O., Berruyer, C., Burke O\u2019Leary, E., Bellier, A., et al., 2024. Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography. Radiology, 312(1), p.e232731.</p> </li> </ol>"},{"location":"citing/#why-cite-cardiotensor","title":"Why Cite <code>cardiotensor</code>?","text":"<p>Citing <code>cardiotensor</code> in your research helps other researchers to discover and reference the software, support continued development, and acknowledges the work invested in creating this package. Proper citations also contribute to the visibility and impact of the <code>cardiotensor</code> project.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for considering contributing to the cardiotensor project! We welcome contributions of all kinds, including bug fixes, feature suggestions, documentation improvements, and more. Follow the guidelines below to ensure a smooth contribution process.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li> <p>Fork the Repository</p> <ul> <li>Go to the GitHub repository and click the \"Fork\" button.</li> <li>Clone your fork locally:     <pre><code>git clone https://github.com/&lt;your-username&gt;/cardiotensor.git\ncd cardiotensor\n</code></pre></li> </ul> </li> <li> <p>Create a Branch</p> <ul> <li>Create a new branch for your feature or bug fix:     <pre><code>git checkout -b my-feature-branch\n</code></pre></li> </ul> </li> <li> <p>Install Dependencies</p> <ul> <li>Ensure you have all required dependencies installed. You can use the provided development dependencies:     <pre><code>pip install -e .[dev]\n</code></pre></li> </ul> </li> <li> <p>Make Your Changes</p> <ul> <li>Make your changes to the codebase, documentation, or both.</li> <li>Follow PEP8 standards for Python code.</li> </ul> </li> <li> <p>Run Tests</p> <ul> <li>Ensure all tests pass and that your contribution does not introduce any issues:     <pre><code>pytest\n</code></pre></li> <li>If you add new features, include corresponding tests.</li> </ul> </li> <li> <p>Commit Your Changes</p> <ul> <li>Write clear and concise commit messages:     <pre><code>git add .\ngit commit -m \"Add feature: XYZ\"\n</code></pre></li> </ul> </li> <li> <p>Push and Create a Pull Request</p> <ul> <li>Push your branch to your fork:     <pre><code>git push origin my-feature-branch\n</code></pre></li> <li>Go to the original repository and create a Pull Request (PR).</li> <li>Provide a clear description of your changes and why they are necessary.</li> </ul> </li> </ol>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<p>To maintain a consistent and readable codebase, please adhere to the following guidelines:</p> <ul> <li>PEP 8: Follow PEP8 coding style standards for Python code.</li> <li>Type Annotations: Include type hints for function arguments and return values.</li> <li>Docstrings: Provide clear docstrings for functions and classes. We recommend using the Google docstring style.</li> </ul>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<ul> <li>Be Respectful: Treat all contributors with respect and professionalism.</li> <li>Follow Standards: Ensure your contributions align with the project's coding and documentation standards.</li> <li>Keep It Simple: Focus on making the project easier to use and maintain.</li> <li>Documentation: Update documentation if your changes affect the usage or functionality of the project.</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you encounter a bug or have a suggestion, please open an issue. Include as much detail as possible:</p> <ul> <li>Steps to reproduce the issue.</li> <li>Expected and actual results.</li> <li>Your environment (e.g., Python version, OS).</li> </ul>"},{"location":"contributing/#contact","title":"Contact","text":"<p>For questions or further assistance, feel free to reach out to the project maintainers via the repository's Discussions or email listed in the repository.</p> <p>We appreciate your contributions and support in making cardiotensor better!</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>To help you get started with cardiotensor, we'll cover a few important topics:</p> <ul> <li>Installing cardiotensor</li> <li>First steps after installation</li> <li>A simple example</li> </ul> <p>Read on, or jump ahead to another section:</p> <ul> <li>Use the reference documentation to find details about something specific.</li> </ul>"},{"location":"getting-started/examples/","title":"Example","text":"<p>This example demonstrates how to use the cardiotensor package with the example provided in the repository. This example will help you understand how to process input data, compute fiber orientations, and visualize results.</p>"},{"location":"getting-started/examples/#example-directory-overview","title":"Example Directory Overview","text":"<p>The <code>./examples/</code> directory contains:</p> <ul> <li>Datasets: Cropped 3D volumes and binary masks for testing and experimentation.</li> <li>Configuration File: A pre-filled <code>parameters_example.conf</code> file for running the workflows.</li> </ul>"},{"location":"getting-started/examples/#data","title":"Data","text":"<ol> <li> <p>Heart Volume:</p> <ul> <li>Path: <code>./data/635.2um_LADAF-2021-17_heart_overview_/</code></li> <li>Description: A downsampled 3D heart image volume designed for testing. The full-resolution dataset is available at the Human Organ Atlas.</li> </ul> </li> <li> <p>Binary Mask:</p> <ul> <li>Path: <code>./data/mask/</code></li> <li>Description: A binary mask used for segmenting the heart from the background.</li> </ul> </li> </ol>"},{"location":"getting-started/examples/#running-the-examples","title":"Running the Examples","text":""},{"location":"getting-started/examples/#installation","title":"Installation","text":"<p>Note</p> <p>See Installation</p> <ol> <li> <p>Clone the repository and install the package:     <pre><code>$ pip install cardiotensor\n</code></pre></p> </li> <li> <p>Navigate to the <code>examples</code> directory:     <pre><code>$ cd examples\n</code></pre></p> </li> </ol>"},{"location":"getting-started/examples/#processing-a-test-slice","title":"Processing a Test Slice","text":"<ol> <li>Open <code>parameters_example.conf</code> and set <code>TEST = True</code> in the <code>[TEST]</code> section.</li> </ol> <p>Note</p> <p>For information about conf file see the section Configuration file</p> <ol> <li>Run the following command:     <pre><code>$ cardio-tensor ./parameters_example.conf\n</code></pre></li> <li>The output will be displayed as a plot for a single slice:</li> </ol> Result from processing a single test slice."},{"location":"getting-started/examples/#processing-the-entire-volume","title":"Processing the Entire Volume","text":"<ol> <li>Set <code>TEST = False</code> in <code>parameters_example.conf</code>.</li> </ol> <p>Note</p> <p>For information about conf file see the section Configuration file</p> <ol> <li>Run the command:     <pre><code>$ cardio-tensor ./parameters_example.conf\n</code></pre></li> <li>Outputs will be saved in the <code>./output</code> directory with the following structure:     <pre><code>./output\n\u251c\u2500\u2500 HA          # Helix angle results\n\u251c\u2500\u2500 IA          # Intrusion angle results\n\u251c\u2500\u2500 FA          # Fractional anisotropy results\n\u2514\u2500\u2500 eigen_vec   # 3rd Eigenvectors\n</code></pre></li> </ol>"},{"location":"getting-started/examples/#visualizing-transmural-profiles","title":"Visualizing Transmural Profiles","text":"<ol> <li> <p>Use the <code>cardio-analysis</code> command:     <pre><code>$ cardio-analysis ./parameters_example.conf 150\n</code></pre>     Replace <code>150</code> with the slice number you wish to analyze.</p> </li> <li> <p>The GUI will appear, allowing you to:</p> <ul> <li>Define a transmural profile line.</li> <li>Adjust parameters like <code>Angle range</code> and <code>Number of lines</code>.</li> <li>Plot and export the profile.  Graphical interface for defining transmural profiles. </li> </ul> <p>The generated profile will resemble:</p> <p> Example of a generated transmural profile. </p> </li> </ol>"},{"location":"getting-started/examples/#visualizing-vector-field","title":"Visualizing Vector field","text":"<p>Note</p> <p>WRITE_VECTORS must be equal to True in the Configuration file</p> <p>Once the structure tensor and eigenvectors have been calculated on the whole volume.</p> <ol> <li> <p>Use the <code>cardio-visualize-vector</code> command:     <pre><code>$ cardio-visualize-vector parameters_example.conf --start 120 --stride 6\n</code></pre></p> <ul> <li> <p><code>--start</code> : Show vectors only from slice 120 to the last slice.</p> </li> <li> <p><code>--stride 6</code> : Show only 1 vector out of every 6.</p> </li> </ul> </li> <li> <p>The plot will appear and you will be able to rotate it by dragging left click</p> <p> Vector field visualization from computed structure tensors using Fury. </p> </li> </ol>"},{"location":"getting-started/examples/#generating-and-visualizing-streamlines","title":"Generating and visualizing streamlines","text":"<ol> <li> <p>Use the <code>cardio-visualize-vector</code> command to generate the streamlines:     <pre><code>$ cardio-generate-streamlines parameters_example.conf --seeds 10000 --start 150\n</code></pre></p> <ul> <li> <p><code>--start</code> : Show vectors only from slice 120 to the last slice.</p> </li> <li> <p><code>--seeds</code> : Number of seeds to start streamlines</p> </li> </ul> <p>Note</p> <p>The streamlines are generated in <code>output/streamlines.npz</code></p> </li> <li> <p>Use the <code>cardio-visualize-streamlines</code> command to plot the streamlines:     <pre><code>$ cardio-visualize-streamlines parameters_example.conf --line-width 1\n</code></pre></p> <ul> <li><code>--line-width</code> : The width of the streamline in the plot.</li> </ul> </li> </ol> Streamline visualization using Fury."},{"location":"getting-started/examples/#notes","title":"Notes","text":"<ul> <li>The provided dataset is for demonstration purposes only.</li> <li>Modify parameters in <code>parameters_example.conf</code> (e.g., <code>SIGMA</code>, <code>RHO</code>) to suit your data.</li> </ul>"},{"location":"getting-started/first-steps/","title":"Verify the installation","text":"<p>After installing cardiotensor, you can verify that cardiotensor is installed correctly by running the command:</p> <pre><code>$ cardio-tensor --help\nusage: cardio-tensor [-h] [--start_index START_INDEX]\n                  [--end_index END_INDEX] [--gpu]\n                  [conf_file_path]\n\nThis script computes orientation for a 3D volume based on the provided configuration file.\n\n...\n</code></pre> <p>You should see a help menu listing the available commands.</p> <p>If no errors occur, the installation is successful. You can then check out our simple example to get familiar with the commands of cardiotensor</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Cardiotensor is a powerful and user-friendly toolkit for analyzing the orientation of cardiomyocites fibers in the heart</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> </ul>"},{"location":"getting-started/installation/#installing-with-pip-recommended","title":"Installing with pip recommended","text":"<p>cardiotensor is published as a Python package and can be installed with <code>pip</code>, ideally by using a virtual environment. Open up a terminal and install cardiotensor with:</p> <pre><code>pip install cardiotensor\n</code></pre>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from Source","text":"<p>To install cardiotensor from source, follow these steps:</p> <ol> <li> <p>Clone the repository from GitHub:</p> <pre><code>$ git clone https://github.com/JosephBrunet/cardiotensor.git\n</code></pre> </li> <li> <p>Navigate to the cloned repository directory:</p> <pre><code>$ cd cardiotensor\n</code></pre> </li> <li> <p>Install the package using pip:</p> <pre><code>$ pip install -e .  # (1)!\n</code></pre> <ol> <li>The <code>-e</code> flag in <code>pip install -e .</code> installs the package in editable mode, allowing changes to the source code to be immediately reflected without reinstallation.</li> </ol> </li> </ol>"},{"location":"getting-started/installation/#uninstallation","title":"Uninstallation","text":"<p>If you need to remove cardiotensor from your system, follow these steps:</p> <pre><code>$ pip uninstall cardio-tensor\n</code></pre> <p>This should remove cardiotensor from your environment.</p>"},{"location":"getting-technical/","title":"Getting Technical","text":"<p>This section provides a deeper understanding of how <code>cardiotensor</code> works, including coordinate systems, angle definitions, structure tensor theory, and tractography method. It is intended for advanced users and developers.</p>"},{"location":"getting-technical/#topics-covered","title":"Topics Covered","text":"<ul> <li> <p>Conventions </p> </li> <li> <p>Structure Tensor: Mathematical background on the structure tensor and eigen decomposition</p> </li> <li> <p>Angle Definitions: Detailed explanation of helix and intrusion angles</p> </li> <li> <p>Fractional Anisotropy </p> </li> <li> <p>Tractography </p> </li> </ul>"},{"location":"getting-technical/angles/","title":"Angle Definitions","text":"<p>This page explains how helix and intrusion angles are calculated from the 3D eigenvector field derived by <code>cardiotensor</code>.</p>"},{"location":"getting-technical/angles/#coordinate-system","title":"Coordinate System","text":"<p>A transformation to cylindrical coordinate system is defined for each voxel based on an approximation of the left ventricle (LV) centerline.</p> <ul> <li>Radial (r): outward from the LV center</li> <li>Circumferential (\u03b8): tangential around the ventricle</li> <li>Longitudinal (z): base to apex direction</li> </ul>"},{"location":"getting-technical/angles/#helix-angle-ha","title":"Helix Angle (HA)","text":"<p>The helix angle is defined as the angle between the third eigenvector \\( \\vec{v}_3 \\) (smallest eigenvalue direction) and the local circumferential plane.</p> <p>It captures the transmural variation of fiber orientation from epicardium to endocardium.</p> <p>Typical pattern: - ~\u221260\u00b0 at epicardium - ~0\u00b0 in mid-wall - ~+60\u00b0 at endocardium</p>"},{"location":"getting-technical/angles/#intrusion-angle-ia","title":"Intrusion Angle (IA)","text":"<p>The intrusion angle is the angle between \\( \\vec{v}_3 \\) and the tangential plane (longitudinal + circumferential).</p> <p>It captures radial deviation of fiber aggregates and can help identify wall thickening or microstructural disruptions.</p>"},{"location":"getting-technical/angles/#angle-ranges","title":"Angle Ranges","text":"<p>Both angles are reported in degrees: - HA: \u221290\u00b0 to +90\u00b0 - IA: \u221290\u00b0 to +90\u00b0</p> <p>Angles are defined in a left-handed cylindrical coordinate system aligned to the LV.</p>"},{"location":"getting-technical/conventions/","title":"Conventions","text":""},{"location":"getting-technical/conventions/#sign-conventions","title":"Sign conventions","text":"<p>Cardiotensor processes full-field orientation data in 3D volumes. Consistent with NumPy matrix indexing, the position (0, 0, 0) refers to the corner at the top-left of the first slice. </p> <p>This convention is maintained across all processing pipelines, including structure tensor calculation and streamline generation.</p>"},{"location":"getting-technical/conventions/#units-of-measurement","title":"Units of measurement","text":"<ul> <li>Lengths are expressed in pixels (or voxels for 3D).</li> <li>Angles (helix, intrusion) are in degrees.</li> <li>Fractional anisotropy is dimensionless, ranging from 0 (isotropic) to 1 (highly anisotropic).</li> </ul>"},{"location":"getting-technical/conventions/#image-format","title":"Image format","text":"<p>All image volumes and masks must be provided as image stack files in formats such as TIFF JP2, PNG, or as single RAW file (MHD).</p> <p>Internally, images are processed as NumPy arrays: <pre><code>volume.shape == (Z, Y, X)\n</code></pre></p> <p>The same format is used throughout the orientation pipeline.</p>"},{"location":"getting-technical/conventions/#orientation-fields-and-eigenvectors","title":"Orientation fields and eigenvectors","text":"<p>Eigenvector maps are saved in the shape <code>(3, Z, Y, X)</code>: - 3 = x, y, z vector components - Each voxel contains the orientation of the 3rd eigenvector (principal myocyte axis)</p> <p>These vector fields are used for computing helix/intrusion angles, streamlines, and for visualization.</p>"},{"location":"getting-technical/fractional_anisotropy/","title":"Fractional Anisotropy (FA)","text":"<p>Fractional Anisotropy (FA) is a scalar value that quantifies the degree of anisotropy (directional dependence) in a tensor field. In <code>cardiotensor</code>, FA is derived from the structure tensor eigenvalues and helps identify regions with organized myocardial fiber orientation.</p>"},{"location":"getting-technical/fractional_anisotropy/#definition","title":"Definition","text":"<p>Given the ordered eigenvalues of the structure tensor \\(\\lambda_1 \\leq \\lambda_2 \\leq \\lambda_3\\), the FA is computed as:</p> \\[ FA = \\sqrt{\\frac{3}{2}} \\cdot \\frac{\\sqrt{(\\lambda_1 - \\bar{\\lambda})^2 + (\\lambda_2 - \\bar{\\lambda})^2 + (\\lambda_3 - \\bar{\\lambda})^2}}{\\sqrt{\\lambda_1^2 + \\lambda_2^2 + \\lambda_3^2}} \\] <p>Where:</p> <ul> <li>\\(\\bar{\\lambda} = (\\lambda_1 + \\lambda_2 + \\lambda_3) / 3\\): mean of the eigenvalues</li> </ul>"},{"location":"getting-technical/fractional_anisotropy/#interpretation","title":"Interpretation","text":"<ul> <li>FA = 0: Isotropic region, where diffusion or structural orientation is equal in all directions (e.g. cavity or noise).</li> <li>FA = 1: Perfectly anisotropic region, structure is highly aligned in one direction (e.g. dense aligned fibers).</li> <li>0 &lt; FA &lt; 1: Varying degrees of anisotropy.</li> </ul> <p>This scalar map can be used to:</p> <ul> <li>Mask low-confidence areas for streamline seeding</li> <li>Identify anatomical regions of high or low alignment</li> <li>Visualize structural organization within the myocardium</li> </ul>"},{"location":"getting-technical/fractional_anisotropy/#output","title":"Output","text":"<p>The FA volume is saved as a single 3D scalar field with the same shape as the input image:</p> <pre><code>fa.shape == (Z, Y, X)\n</code></pre> <p>It can be saved as TIFF or JP2 and visualized with standard volume rendering tools.</p>"},{"location":"getting-technical/fractional_anisotropy/#thresholding-in-tractography","title":"Thresholding in Tractography","text":"<p>FA values can be used to restrict streamline propagation:</p> <ul> <li>Minimum FA threshold: ensures streamlines are seeded and propagated only in structured regions</li> <li>Default values range from 0.1 to 0.2 depending on noise level and resolution</li> </ul>"},{"location":"getting-technical/structure_tensor/","title":"Structure Tensor Computation","text":"<p>The structure tensor is a fundamental tool in 3D image analysis used to estimate local orientation and anisotropy. In <code>cardiotensor</code>, it is computed per voxel to quantify the principal direction of cardiomyocyte aggregates.</p>"},{"location":"getting-technical/structure_tensor/#what-is-a-structure-tensor","title":"What is a Structure Tensor?","text":"<p>The structure tensor \\(S\\) is a 3-by-3 symmetric matrix that summarizes how intensity varies in a local neighborhood of a 3D image. It is defined as:</p> \\[ S = K_\\rho * (\\nabla V_\\sigma \\cdot \\nabla V_\\sigma^T) \\] <p>Where:</p> <ul> <li>\\(V\\): 3D image volume</li> <li>\\(\\nabla V_\\sigma\\): smoothed gradient (via Gaussian derivative with noise scale \\(\\sigma\\))</li> <li>\\(K_\\rho\\): Gaussian kernel with standard deviation \\(\\rho\\) (integration scale)</li> <li>\\(*\\): convolution over a local neighborhood</li> </ul> <p>This matrix encodes orientation and intensity variation.</p>"},{"location":"getting-technical/structure_tensor/#implementation","title":"Implementation","text":"<p>Cardiotensor computes the structure tensor using the structure-tensor Python library.</p> <ul> <li>It supports parallel computation and automatically uses the GPU (via CuPy) if available.</li> <li>CPU-based execution falls back to NumPy for full compatibility.</li> <li>This makes orientation estimation fast and scalable on large datasets.</li> </ul>"},{"location":"getting-technical/structure_tensor/#step-by-step-computation","title":"Step-by-Step Computation","text":"<ol> <li> <p>Noise Filtering</p> </li> <li> <p>Compute gradients \\(V_x, V_y, V_z\\) using Gaussian derivative filters (standard deviation \\(\\sigma\\)).</p> </li> <li> <p>Outer Product</p> </li> <li> <p>Form tensor components:</p> <ul> <li>\\(V_x^2, V_y^2, V_z^2, V_xV_y, V_xV_z, V_yV_z\\)</li> </ul> </li> <li> <p>Smoothing</p> </li> <li> <p>Convolve each component with a Gaussian kernel (standard deviation \\(\\rho\\)) to compute final tensor:</p> </li> </ol> \\[ S = \\begin{bmatrix} \\langle V_x^2 \\rangle &amp; \\langle V_x V_y \\rangle &amp; \\langle V_x V_z \\rangle \\\\ \\langle V_x V_y \\rangle &amp; \\langle V_y^2 \\rangle &amp; \\langle V_y V_z \\rangle \\\\ \\langle V_x V_z \\rangle &amp; \\langle V_y V_z \\rangle &amp; \\langle V_z^2 \\rangle \\end{bmatrix} \\]"},{"location":"getting-technical/structure_tensor/#eigen-decomposition","title":"Eigen Decomposition","text":"<p>Each structure tensor \\(S\\) is decomposed into eigenvalues \\(\\lambda_1 \\leq \\lambda_2 \\leq \\lambda_3\\) and corresponding eigenvectors \\(\\vec{v}_1, \\vec{v}_2, \\vec{v}_3\\).</p> <ul> <li>\\(\\vec{v}_1\\): direction with least intensity change (principal fiber direction)</li> <li>\\(\\vec{v}_3\\): direction of greatest intensity change</li> </ul>"},{"location":"getting-technical/structure_tensor/#output-and-interpretation","title":"Output and Interpretation","text":"<ul> <li>The third eigenvector \\(\\vec{v}_1\\) is stored as the local myocyte orientation.</li> <li>Helix and intrusion angles are computed from \\(\\vec{v}_1\\) after transforming it into cylindrical coordinates.</li> <li>Fractional Anisotropy (FA) is computed using the three eigenvalues (see FA section).</li> </ul>"},{"location":"getting-technical/structure_tensor/#parameters","title":"Parameters","text":"<ul> <li>\\(\\sigma\\) (noise scale): Controls how much local variation is smoothed in gradient calculation.</li> <li>\\(\\rho\\) (integration scale): Defines the neighborhood size for averaging the tensor field.</li> </ul> <p>Higher \\(\\sigma\\) and \\(\\rho\\) values increase robustness to noise but reduce spatial precision.</p>"},{"location":"getting-technical/tractography/","title":"Tractography","text":"<p>Tractography in <code>cardiotensor</code> is the process of generating streamlines that follow local myocyte bundle orientation within a 3D vector field. It enables visual and quantitative analysis of cardiac fiber organization.</p>"},{"location":"getting-technical/tractography/#principle","title":"Principle","text":"<p>Streamlines are computed by tracing the path along the principal orientation vector (3rd eigenvector \\(\\vec{v}_1\\)) from the structure tensor. Integration follows the local direction of this vector across voxels.</p> <p>This method is analogous to diffusion MRI tractography, but uses structure tensor-based orientation fields derived from high-resolution imaging.</p>"},{"location":"getting-technical/tractography/#algorithm-overview","title":"Algorithm Overview","text":""},{"location":"getting-technical/tractography/#seeding","title":"Seeding:","text":"<ul> <li>Seed points are placed uniformly in a user-defined volume or mask.</li> <li>Seeding can be restricted based on FA or binary masks.</li> </ul>"},{"location":"getting-technical/tractography/#integration","title":"Integration:","text":"<ul> <li>Streamlines are generated using numerical integration (e.g., Euler method).</li> <li>Step size and number of steps control streamline length and smoothness.</li> </ul>"},{"location":"getting-technical/tractography/#termination","title":"Termination:","text":"<p>A streamline stops when:</p> <ul> <li>FA is below a threshold (default 0.1)</li> <li>Angle between successive steps exceeds a curvature threshold</li> <li>It leaves the image bounds</li> </ul>"},{"location":"getting-technical/tractography/#filtering","title":"Filtering:","text":"<ul> <li>Short or low-quality streamlines can be removed based on length or curvature.</li> </ul>"},{"location":"getting-technical/tractography/#parameters","title":"Parameters","text":"<ul> <li><code>--seeds</code>: number of seed points</li> <li><code>--bin</code>: Bin the vector field and angle values</li> <li><code>--step</code>: integration step size (in voxel units)</li> <li><code>--min-fa</code>: minimum FA to start/continue</li> <li><code>--max-angle</code>: curvature constraint (in degrees)</li> <li><code>--mask</code>: optional binary mask to restrict seeding</li> </ul> <p>Example CLI usage:</p> <pre><code>cardio-generate conf.toml --seeds 10000 --bin 2\n</code></pre>"},{"location":"getting-technical/tractography/#output","title":"Output","text":"<p>Streamlines are saved in <code>.npz</code> format as:</p> <ul> <li><code>streamlines</code>: list of 3D coordinate arrays</li> <li><code>HA</code>: helix angle per vertex (optional)</li> </ul> <p>They can be visualized using tools like:</p> <ul> <li>Fury (Python-based 3D visualization)</li> <li>ParaView (via VTK export)</li> </ul>"},{"location":"getting-technical/tractography/#applications","title":"Applications","text":"<ul> <li>Visualizing transmural fiber architecture</li> <li>Identifying laminar structures and myocardial disarray</li> <li>Comparing healthy vs pathological fiber orientation</li> <li>Enabling tract-based statistics or mapping</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>The reference section provides information about specific parts of cardiotensor:</p> <ul> <li>Commands: A reference for cardiotensor's command line interface.</li> <li>Configuration file: A reference for cardiotensor's configuration file.</li> <li>API: A reference for cardiotensor's modules and functions.</li> </ul>"},{"location":"reference/api/","title":"API","text":""},{"location":"reference/api/#cardiotensor","title":"cardiotensor","text":"<p>Modules:</p> <ul> <li> <code>analysis</code>           \u2013            </li> <li> <code>launcher</code>           \u2013            </li> <li> <code>orientation</code>           \u2013            </li> <li> <code>tractography</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis","title":"analysis","text":"<p>Modules:</p> <ul> <li> <code>analysis_functions</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions","title":"analysis_functions","text":"<p>Functions:</p> <ul> <li> <code>calculate_intensities</code>             \u2013              <p>Calculate intensity profiles along multiple lines.</p> </li> <li> <code>find_end_points</code>             \u2013              <p>Find the end points for lines at different angles within a range.</p> </li> <li> <code>plot_intensity</code>             \u2013              <p>Plot intensity profiles with mean and percentile shading.</p> </li> <li> <code>save_intensity</code>             \u2013              <p>Save intensity profiles to a CSV file.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.calculate_intensities","title":"calculate_intensities","text":"<pre><code>calculate_intensities(img_helix: ndarray, start_point: tuple[int, int], end_point: tuple[int, int], angle_range: float = 5, N_line: int = 10, max_value: float | None = None, min_value: float | None = None) -&gt; list[ndarray]\n</code></pre> <p>Calculate intensity profiles along multiple lines.</p> <p>Parameters: img_helix (np.ndarray): The image array. start_point (Tuple[int, int]): The starting point of the line. end_point (Tuple[int, int]): The ending point of the line. angle_range (float, optional): The range of angles to consider in degrees. Default is 5. N_line (int, optional): The number of lines to generate. Default is 10. max_value (Optional[float], optional): Maximum value for intensity normalization. Default is None. min_value (Optional[float], optional): Minimum value for intensity normalization. Default is None.</p> <p>Returns: List[np.ndarray]: List of intensity profiles for each line.</p>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.find_end_points","title":"find_end_points","text":"<pre><code>find_end_points(start_point: tuple[float, float], end_point: tuple[float, float], angle_range: float, N_line: int) -&gt; ndarray\n</code></pre> <p>Find the end points for lines at different angles within a range.</p> <p>Parameters: start_point (Tuple[int, int]): The starting point of the main line. end_point (Tuple[int, int]): The ending point of the main line. angle_range (float): The range of angles to consider in degrees. N_line (int): The number of lines to generate within the range.</p> <p>Returns: np.ndarray: Array of end points for the generated lines.</p>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.plot_intensity","title":"plot_intensity","text":"<pre><code>plot_intensity(intensity_profiles: list[ndarray], label_y: str = '', x_max_lim: float | None = None, x_min_lim: float | None = None, y_max_lim: float | None = None, y_min_lim: float | None = None) -&gt; None\n</code></pre> <p>Plot intensity profiles with mean and percentile shading.</p> <p>Parameters: intensity_profiles (List[np.ndarray]): List of intensity profiles. label_y (str, optional): Label for the y-axis. Default is an empty string. x_max_lim (Optional[float], optional): Maximum x-axis limit. Default is None. x_min_lim (Optional[float], optional): Minimum x-axis limit. Default is None. y_max_lim (Optional[float], optional): Maximum y-axis limit. Default is None. y_min_lim (Optional[float], optional): Minimum y-axis limit. Default is None.</p>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.save_intensity","title":"save_intensity","text":"<pre><code>save_intensity(intensity_profiles: list[ndarray], save_path: str) -&gt; None\n</code></pre> <p>Save intensity profiles to a CSV file.</p> <p>Parameters: intensity_profiles (List[np.ndarray]): List of intensity profiles. save_path (str): Path to save the CSV file.</p> <p>Returns: None</p>"},{"location":"reference/api/#cardiotensor.launcher","title":"launcher","text":"<p>Modules:</p> <ul> <li> <code>slurm_launcher</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher","title":"slurm_launcher","text":"<p>Functions:</p> <ul> <li> <code>is_chunk_done</code>             \u2013              <p>Check if all output files (HA, IA, FA) for a given chunk are already present.</p> </li> <li> <code>monitor_job_output</code>             \u2013              <p>Monitor the output directory until all images are processed.</p> </li> <li> <code>slurm_launcher</code>             \u2013              <p>Launch Slurm jobs for 3D data processing.</p> </li> <li> <code>submit_job_to_slurm</code>             \u2013              <p>Submit a Slurm job and return its job ID.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done","title":"is_chunk_done","text":"<pre><code>is_chunk_done(output_dir: str, start: int, end: int, output_format: str = 'jp2') -&gt; bool\n</code></pre> <p>Check if all output files (HA, IA, FA) for a given chunk are already present.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if all expected output files exist, False otherwise.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done(output_dir)","title":"<code>output_dir</code>","text":"(<code>str</code>)           \u2013            <p>Base output directory containing HA/IA/FA folders.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done(start)","title":"<code>start</code>","text":"(<code>int</code>)           \u2013            <p>Start index of the chunk (inclusive).</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done(end)","title":"<code>end</code>","text":"(<code>int</code>)           \u2013            <p>End index of the chunk (exclusive).</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.is_chunk_done(output_format)","title":"<code>output_format</code>","text":"(<code>str</code>, default:                   <code>'jp2'</code> )           \u2013            <p>File extension for the output images (e.g., \"jp2\", \"tif\").</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.monitor_job_output","title":"monitor_job_output","text":"<pre><code>monitor_job_output(output_directory: str, total_images: int, file_extension: str) -&gt; None\n</code></pre> <p>Monitor the output directory until all images are processed.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.monitor_job_output(output_directory)","title":"<code>output_directory</code>","text":"(<code>str</code>)           \u2013            <p>Path to the directory to monitor.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.monitor_job_output(total_images)","title":"<code>total_images</code>","text":"(<code>int</code>)           \u2013            <p>Total number of expected images.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.monitor_job_output(file_extension)","title":"<code>file_extension</code>","text":"(<code>str</code>)           \u2013            <p>File extension to monitor for.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.slurm_launcher","title":"slurm_launcher","text":"<pre><code>slurm_launcher(conf_file_path: str) -&gt; None\n</code></pre> <p>Launch Slurm jobs for 3D data processing.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.slurm_launcher(conf_file_path)","title":"<code>conf_file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm","title":"submit_job_to_slurm","text":"<pre><code>submit_job_to_slurm(executable_path: str, conf_file_path: str, start_image: int, end_image: int, N_chunk: int = 10, mem_needed: int = 64) -&gt; int\n</code></pre> <p>Submit a Slurm job and return its job ID.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The Slurm job ID.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(executable_path)","title":"<code>executable_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the executable script.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(conf_file_path)","title":"<code>conf_file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(start_image)","title":"<code>start_image</code>","text":"(<code>int</code>)           \u2013            <p>Index of the first image to process.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(end_image)","title":"<code>end_image</code>","text":"(<code>int</code>)           \u2013            <p>Index of the last image to process.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(N_chunk)","title":"<code>N_chunk</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of chunks for the job. Default is 10.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(mem_needed)","title":"<code>mem_needed</code>","text":"(<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Memory required in GB. Default is 64.</p>"},{"location":"reference/api/#cardiotensor.orientation","title":"orientation","text":"<p>Modules:</p> <ul> <li> <code>orientation_computation_functions</code>           \u2013            </li> <li> <code>orientation_computation_pipeline</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions","title":"orientation_computation_functions","text":"<p>Functions:</p> <ul> <li> <code>adjust_start_end_index</code>             \u2013              <p>Adjusts start and end indices for image processing, considering padding and test mode.</p> </li> <li> <code>calculate_center_vector</code>             \u2013              <p>Compute the linear regression vector for a given set of 3D points.</p> </li> <li> <code>calculate_structure_tensor</code>             \u2013              <p>Calculates the structure tensor of a volume.</p> </li> <li> <code>compute_fraction_anisotropy</code>             \u2013              <p>Computes Fractional Anisotropy (FA) from eigenvalues of a structure tensor.</p> </li> <li> <code>compute_helix_and_transverse_angles</code>             \u2013              <p>Computes helix and transverse angles from a 2D vector field.</p> </li> <li> <code>interpolate_points</code>             \u2013              <p>Generates interpolated points using cubic spline interpolation for a given set of 3D points.</p> </li> <li> <code>plot_images</code>             \u2013              <p>Plots images of the heart with helix, intrusion, and FA annotations.</p> </li> <li> <code>remove_padding</code>             \u2013              <p>Removes padding from the volume, eigenvalues, and eigenvectors.</p> </li> <li> <code>rotate_vectors_to_new_axis</code>             \u2013              <p>Rotates a vector field slice to align with a new axis.</p> </li> <li> <code>write_images</code>             \u2013              <p>Writes processed images to the specified directory.</p> </li> <li> <code>write_vector_field</code>             \u2013              <p>Saves a vector field slice to the specified directory in .npy format.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index","title":"adjust_start_end_index","text":"<pre><code>adjust_start_end_index(start_index: int, end_index: int, N_img: int, padding_start: int, padding_end: int, is_test: bool, n_slice: int) -&gt; tuple[int, int]\n</code></pre> <p>Adjusts start and end indices for image processing, considering padding and test mode.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>Tuple[int, int]: Adjusted start and end indices.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>The initial start index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(end_index)","title":"<code>end_index</code>","text":"(<code>int</code>)           \u2013            <p>The initial end index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(N_img)","title":"<code>N_img</code>","text":"(<code>int</code>)           \u2013            <p>Number of images in the volume data.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(padding_start)","title":"<code>padding_start</code>","text":"(<code>int</code>)           \u2013            <p>Padding to add at the start.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(padding_end)","title":"<code>padding_end</code>","text":"(<code>int</code>)           \u2013            <p>Padding to add at the end.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(is_test)","title":"<code>is_test</code>","text":"(<code>bool</code>)           \u2013            <p>Flag indicating whether in test mode.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(n_slice)","title":"<code>n_slice</code>","text":"(<code>int</code>)           \u2013            <p>Test slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_center_vector","title":"calculate_center_vector","text":"<pre><code>calculate_center_vector(points: ndarray) -&gt; ndarray\n</code></pre> <p>Compute the linear regression vector for a given set of 3D points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: A single 3D unit vector representing the direction of the best-fit line.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_center_vector(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An Nx3 array of (x, y, z) coordinates representing the curved line.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor","title":"calculate_structure_tensor","text":"<pre><code>calculate_structure_tensor(volume: ndarray, SIGMA: float, RHO: float, TRUNCATE: float = 4.0, devices: list[str] | None = None, block_size: int = 200, use_gpu: bool = False, dtype: type = float32) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Calculates the structure tensor of a volume.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>tuple[np.ndarray, np.ndarray]: Eigenvalues and eigenvectors of the structure tensor.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The 3D volume data.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(SIGMA)","title":"<code>SIGMA</code>","text":"(<code>float</code>)           \u2013            <p>Sigma value for Gaussian smoothing.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(RHO)","title":"<code>RHO</code>","text":"(<code>float</code>)           \u2013            <p>Rho value for Gaussian smoothing.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(devices)","title":"<code>devices</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>List of devices for parallel processing (e.g., ['cpu', 'cuda:0']).</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(block_size)","title":"<code>block_size</code>","text":"(<code>int</code>, default:                   <code>200</code> )           \u2013            <p>Size of the blocks for processing. Default is 200.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(use_gpu)","title":"<code>use_gpu</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, uses GPU for calculations. Default is False.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_fraction_anisotropy","title":"compute_fraction_anisotropy","text":"<pre><code>compute_fraction_anisotropy(eigenvalues_2d: ndarray) -&gt; ndarray\n</code></pre> <p>Computes Fractional Anisotropy (FA) from eigenvalues of a structure tensor.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Fractional Anisotropy values.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_fraction_anisotropy(eigenvalues_2d)","title":"<code>eigenvalues_2d</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D array of eigenvalues (l1, l2, l3).</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_helix_and_transverse_angles","title":"compute_helix_and_transverse_angles","text":"<pre><code>compute_helix_and_transverse_angles(vector_field_2d: ndarray, center_point: tuple[int, int, int]) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Computes helix and transverse angles from a 2D vector field.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>Tuple[np.ndarray, np.ndarray]: Helix and transverse angle arrays.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_helix_and_transverse_angles(vector_field_2d)","title":"<code>vector_field_2d</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D orientation vector field.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_helix_and_transverse_angles(center_point)","title":"<code>center_point</code>","text":"(<code>Tuple[int, int, int]</code>)           \u2013            <p>Coordinates of the center point.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.interpolate_points","title":"interpolate_points","text":"<pre><code>interpolate_points(points: list[tuple[float, float, float]], N_img: int) -&gt; ndarray\n</code></pre> <p>Generates interpolated points using cubic spline interpolation for a given set of 3D points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Array of interpolated points.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.interpolate_points(points)","title":"<code>points</code>","text":"(<code>list[tuple[float, float, float]]</code>)           \u2013            <p>A list of (x, y, z) points.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.interpolate_points(N_img)","title":"<code>N_img</code>","text":"(<code>int</code>)           \u2013            <p>The number of slices in the z-dimension.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images","title":"plot_images","text":"<pre><code>plot_images(img: ndarray, img_helix: ndarray, img_intrusion: ndarray, img_FA: ndarray, center_point: tuple[int, int, int]) -&gt; None\n</code></pre> <p>Plots images of the heart with helix, intrusion, and FA annotations.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(img)","title":"<code>img</code>","text":"(<code>ndarray</code>)           \u2013            <p>Grayscale image of the heart.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(img_helix)","title":"<code>img_helix</code>","text":"(<code>ndarray</code>)           \u2013            <p>Helix angle image.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(img_intrusion)","title":"<code>img_intrusion</code>","text":"(<code>ndarray</code>)           \u2013            <p>Intrusion angle image.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(img_FA)","title":"<code>img_FA</code>","text":"(<code>ndarray</code>)           \u2013            <p>Fractional Anisotropy (FA) image.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(center_point)","title":"<code>center_point</code>","text":"(<code>Tuple[int, int, int]</code>)           \u2013            <p>Coordinates of the center point.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding","title":"remove_padding","text":"<pre><code>remove_padding(volume: ndarray, val: ndarray, vec: ndarray, padding_start: int, padding_end: int) -&gt; tuple[ndarray, ndarray, ndarray]\n</code></pre> <p>Removes padding from the volume, eigenvalues, and eigenvectors.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray, ndarray]</code>           \u2013            <p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Adjusted data without padding.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The 3D volume data.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(val)","title":"<code>val</code>","text":"(<code>ndarray</code>)           \u2013            <p>The eigenvalues.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(vec)","title":"<code>vec</code>","text":"(<code>ndarray</code>)           \u2013            <p>The eigenvectors.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(padding_start)","title":"<code>padding_start</code>","text":"(<code>int</code>)           \u2013            <p>Padding at the start to remove.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(padding_end)","title":"<code>padding_end</code>","text":"(<code>int</code>)           \u2013            <p>Padding at the end to remove.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.rotate_vectors_to_new_axis","title":"rotate_vectors_to_new_axis","text":"<pre><code>rotate_vectors_to_new_axis(vector_field_slice: ndarray, new_axis_vec: ndarray) -&gt; ndarray\n</code></pre> <p>Rotates a vector field slice to align with a new axis.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Rotated vectors aligned with the new axis.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.rotate_vectors_to_new_axis(vector_field_slice)","title":"<code>vector_field_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of vectors to rotate.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.rotate_vectors_to_new_axis(new_axis_vec)","title":"<code>new_axis_vec</code>","text":"(<code>ndarray</code>)           \u2013            <p>The new axis to align vectors with.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images","title":"write_images","text":"<pre><code>write_images(img_helix: ndarray, img_intrusion: ndarray, img_FA: ndarray, start_index: int, OUTPUT_DIR: str, OUTPUT_FORMAT: str, OUTPUT_TYPE: str, z: int) -&gt; None\n</code></pre> <p>Writes processed images to the specified directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(img_helix)","title":"<code>img_helix</code>","text":"(<code>ndarray</code>)           \u2013            <p>Image data for helix angles.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(img_intrusion)","title":"<code>img_intrusion</code>","text":"(<code>ndarray</code>)           \u2013            <p>Image data for intrusion angles.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(img_FA)","title":"<code>img_FA</code>","text":"(<code>ndarray</code>)           \u2013            <p>Image data for fractional anisotropy.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>Starting index for filenames.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(OUTPUT_DIR)","title":"<code>OUTPUT_DIR</code>","text":"(<code>str</code>)           \u2013            <p>Directory to save the images.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(OUTPUT_FORMAT)","title":"<code>OUTPUT_FORMAT</code>","text":"(<code>str</code>)           \u2013            <p>Format of the output files ('tif' or 'jp2').</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(OUTPUT_TYPE)","title":"<code>OUTPUT_TYPE</code>","text":"(<code>str</code>)           \u2013            <p>Type of output ('8bit' or 'rgb').</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(z)","title":"<code>z</code>","text":"(<code>int</code>)           \u2013            <p>Current slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field","title":"write_vector_field","text":"<pre><code>write_vector_field(vector_field_slice: ndarray, start_index: int, output_dir: str, slice_idx: int) -&gt; None\n</code></pre> <p>Saves a vector field slice to the specified directory in .npy format.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(vector_field_slice)","title":"<code>vector_field_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Vector field data slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>Starting index for filenames.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(output_dir)","title":"<code>output_dir</code>","text":"(<code>str</code>)           \u2013            <p>Directory to save the vector field.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(slice_idx)","title":"<code>slice_idx</code>","text":"(<code>int</code>)           \u2013            <p>Current slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline","title":"orientation_computation_pipeline","text":"<p>Functions:</p> <ul> <li> <code>compute_orientation</code>             \u2013              <p>Compute the orientation for a volume dataset based on the configuration.</p> </li> <li> <code>compute_slice_angles_and_anisotropy</code>             \u2013              <p>Compute helix angles, transverse angles, and fractional anisotropy for a slice.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation","title":"compute_orientation","text":"<pre><code>compute_orientation(conf_file_path: str, start_index: int = 0, end_index: int | None = None) -&gt; None\n</code></pre> <p>Compute the orientation for a volume dataset based on the configuration.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(conf_file_path)","title":"<code>conf_file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Start index for processing. Default is 0.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(end_index)","title":"<code>end_index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>End index for processing. Default is None.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy","title":"compute_slice_angles_and_anisotropy","text":"<pre><code>compute_slice_angles_and_anisotropy(z: int, vector_field_slice: ndarray, img_slice: ndarray, center_point: ndarray, eigen_val_slice: ndarray, center_line: ndarray, OUTPUT_DIR: str, OUTPUT_FORMAT: str, OUTPUT_TYPE: str, start_index: int, WRITE_VECTORS: bool, WRITE_ANGLES: bool, IS_TEST: bool) -&gt; None\n</code></pre> <p>Compute helix angles, transverse angles, and fractional anisotropy for a slice.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(z)","title":"<code>z</code>","text":"(<code>int</code>)           \u2013            <p>Index of the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(vector_field_slice)","title":"<code>vector_field_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Vector field for the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(img_slice)","title":"<code>img_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Image data for the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(center_point)","title":"<code>center_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>Center point for alignment.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(eigen_val_slice)","title":"<code>eigen_val_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Eigenvalues for the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(center_line)","title":"<code>center_line</code>","text":"(<code>ndarray</code>)           \u2013            <p>Center line for alignment.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(OUTPUT_DIR)","title":"<code>OUTPUT_DIR</code>","text":"(<code>str</code>)           \u2013            <p>Directory to save the output.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(OUTPUT_FORMAT)","title":"<code>OUTPUT_FORMAT</code>","text":"(<code>str</code>)           \u2013            <p>Format for the output files (e.g., \"tif\").</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(OUTPUT_TYPE)","title":"<code>OUTPUT_TYPE</code>","text":"(<code>str</code>)           \u2013            <p>Type of output (e.g., \"8bits\", \"rgb\").</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>Start index of the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(WRITE_VECTORS)","title":"<code>WRITE_VECTORS</code>","text":"(<code>bool</code>)           \u2013            <p>Whether to output vector fields.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(WRITE_ANGLES)","title":"<code>WRITE_ANGLES</code>","text":"(<code>bool</code>)           \u2013            <p>Whether to output angles and fractional anisotropy.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(IS_TEST)","title":"<code>IS_TEST</code>","text":"(<code>bool</code>)           \u2013            <p>Whether in test mode.</p>"},{"location":"reference/api/#cardiotensor.tractography","title":"tractography","text":"<p>Modules:</p> <ul> <li> <code>generate_streamlines</code>           \u2013            </li> <li> <code>visualize_streamlines</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines","title":"generate_streamlines","text":"<p>Functions:</p> <ul> <li> <code>generate_streamlines_from_vector_field</code>             \u2013              <p>Given a 3D vector_field (shape = (3, Z, Y, X)) and a set of integer\u2010seed voxels,</p> </li> <li> <code>trace_streamline</code>             \u2013              <p>Trace one streamline from <code>start_pt</code> (z,y,x) in the continuous vector_field.</p> </li> <li> <code>trilinear_interpolate_scalar</code>             \u2013              <p>Trilinearly interpolate a scalar volume at fractional point (z, y, x).</p> </li> <li> <code>trilinear_interpolate_vector</code>             \u2013              <p>Given a fractional (z,y,x), returns the trilinearly\u2010interpolated 3\u2010vector</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines.generate_streamlines_from_vector_field","title":"generate_streamlines_from_vector_field","text":"<pre><code>generate_streamlines_from_vector_field(vector_field: ndarray, seed_points: ndarray, fa_volume: ndarray | None = None, fa_threshold: float = 0.1, step_length: float = 0.5, max_steps: int | None = None, angle_threshold: float = 60.0, min_length_pts: int = 10) -&gt; list[list[tuple[float, float, float]]]\n</code></pre> <p>Given a 3D vector_field (shape = (3, Z, Y, X)) and a set of integer\u2010seed voxels, returns a list of streamlines (each streamline = a list of float (z,y,x) points), filtered so that only those longer than <code>min_length_pts</code> are kept. Displays a progress bar during processing.</p>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines.trace_streamline","title":"trace_streamline","text":"<pre><code>trace_streamline(start_pt: tuple[float, float, float], vector_field: ndarray, fa_volume: ndarray | None = None, fa_threshold: float = 0.1, step_length: float = 0.5, max_steps: int | None = 1000, angle_threshold: float = 60.0, eps: float = 1e-10) -&gt; list[tuple[float, float, float]]\n</code></pre> <p>Trace one streamline from <code>start_pt</code> (z,y,x) in the continuous vector_field. - Interpolate &amp; normalize each sub\u2010step - Move forward by <code>step_length</code> voxels each step (Euler or RK4) - Stop if turning angle &gt; angle_threshold or out of bounds or <code>vec</code> too small. - If max_steps is None, trace until a stopping condition is hit (no hard limit).</p>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines.trilinear_interpolate_scalar","title":"trilinear_interpolate_scalar","text":"<pre><code>trilinear_interpolate_scalar(volume: ndarray, pt: tuple[float, float, float]) -&gt; float\n</code></pre> <p>Trilinearly interpolate a scalar volume at fractional point (z, y, x). Clamps to valid range.</p>"},{"location":"reference/api/#cardiotensor.tractography.generate_streamlines.trilinear_interpolate_vector","title":"trilinear_interpolate_vector","text":"<pre><code>trilinear_interpolate_vector(vector_field: ndarray, pt: tuple[float, float, float]) -&gt; ndarray\n</code></pre> <p>Given a fractional (z,y,x), returns the trilinearly\u2010interpolated 3\u2010vector from <code>vector_field</code> (shape = (3, Z, Y, X)). Clamps to nearest voxel if out\u2010of\u2010bounds.</p>"},{"location":"reference/api/#cardiotensor.tractography.visualize_streamlines","title":"visualize_streamlines","text":"<p>Functions:</p> <ul> <li> <code>compute_elevation_angles</code>             \u2013              <p>Compute per-vertex elevation angle.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.tractography.visualize_streamlines.compute_elevation_angles","title":"compute_elevation_angles","text":"<pre><code>compute_elevation_angles(streamlines)\n</code></pre> <p>Compute per-vertex elevation angle.</p>"},{"location":"reference/api/#cardiotensor.utils","title":"utils","text":"<p>Modules:</p> <ul> <li> <code>DataReader</code>           \u2013            </li> <li> <code>downsampling</code>           \u2013            </li> <li> <code>plot_vector_field</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader","title":"DataReader","text":"<p>Classes:</p> <ul> <li> <code>DataReader</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader","title":"DataReader","text":"<pre><code>DataReader(path: str | Path)\n</code></pre> <p>Initializes the DataReader with a path to the volume.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>load_volume</code>             \u2013              <p>Loads the volume data based on the detected volume type.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>Path to the volume directory or file.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume","title":"load_volume","text":"<pre><code>load_volume(start_index: int = 0, end_index: int | None = None, unbinned_shape: tuple[int, int, int] | None = None) -&gt; ndarray\n</code></pre> <p>Loads the volume data based on the detected volume type.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Loaded (and possibly resized) volume data.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Start index for slicing (for stacks).</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume(end_index)","title":"<code>end_index</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>End index for slicing (for stacks). If None, loads the entire stack.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume(unbinned_shape)","title":"<code>unbinned_shape</code>","text":"(<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>Shape of the volume without downsampling. Default is None (no binning).</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling","title":"downsampling","text":"<p>Functions:</p> <ul> <li> <code>chunked_downsample_vector_volume_mp</code>             \u2013              <p>Multi\u2010process + progress\u2010bar version of chunked_downsample_vector_volume.</p> </li> <li> <code>downsample_vector_volume</code>             \u2013              <p>Downsamples a vector volume using multiprocessing.</p> </li> <li> <code>downsample_volume</code>             \u2013              <p>Downsamples a 3D image volume along the Z and XY axes and saves as 8-bit images.</p> </li> <li> <code>process_image_block</code>             \u2013              <p>Process a Z-block of images by averaging along the Z axis,</p> </li> <li> <code>process_vector_block</code>             \u2013              <p>Processes a single block of numpy files and saves the downsampled output.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.downsampling.chunked_downsample_vector_volume_mp","title":"chunked_downsample_vector_volume_mp","text":"<pre><code>chunked_downsample_vector_volume_mp(input_npy_dir: Path, bin_factor: int, output_dir: Path) -&gt; None\n</code></pre> <p>Multi\u2010process + progress\u2010bar version of chunked_downsample_vector_volume. Reads a directory of per\u2010slice NumPy files (shape = (3, H, W) each), groups every <code>bin_factor</code> consecutive slices into blocks, averages, downsamples, renormalizes, and writes each block as one coarse slice in output_dir/bin{bin_factor}/eigen_vec/.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.chunked_downsample_vector_volume_mp--parameters","title":"Parameters","text":"<p>input_npy_dir : Path     Directory containing fine\u2010scale \u201ceigen_vec_*.npy\u201d files, each shape (3, H, W). bin_factor : int     Number of fine Z\u2010slices per block. output_dir : Path     Base output directory. Will create output_dir/bin{bin_factor}/eigen_vec/.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume","title":"downsample_vector_volume","text":"<pre><code>downsample_vector_volume(input_npy: Path, bin_factor: int, output_dir: Path) -&gt; None\n</code></pre> <p>Downsamples a vector volume using multiprocessing.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume(input_npy)","title":"<code>input_npy</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the directory containing numpy files.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume","title":"downsample_volume","text":"<pre><code>downsample_volume(input_path: Path, bin_factor: int, output_dir: Path, subfolder: str = 'HA', out_ext: str = 'tif', min_value: float = 0, max_value: float = 255) -&gt; None\n</code></pre> <p>Downsamples a 3D image volume along the Z and XY axes and saves as 8-bit images.</p> <p>This function reads a volumetric image dataset (e.g. TIFF stack) using DataReader, performs block averaging along the Z-axis and spatial downsampling in XY, then saves each resulting slice in a specified output directory as 8-bit images.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(input_path)","title":"<code>input_path</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the directory containing the image stack.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Factor to downsample in XY and the number of Z-slices to average per output slice.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output root directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(subfolder)","title":"<code>subfolder</code>","text":"(<code>str</code>, default:                   <code>'HA'</code> )           \u2013            <p>Subdirectory name under <code>binX/</code> to place results (default: \"HA\").</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(out_ext)","title":"<code>out_ext</code>","text":"(<code>str</code>, default:                   <code>'tif'</code> )           \u2013            <p>Output image format extension (e.g., 'tif', 'png').</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(min_value)","title":"<code>min_value</code>","text":"(<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Minimum value for intensity normalization to 8-bit.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(max_value)","title":"<code>max_value</code>","text":"(<code>float</code>, default:                   <code>255</code> )           \u2013            <p>Maximum value for intensity normalization to 8-bit.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block","title":"process_image_block","text":"<pre><code>process_image_block(file_list, block_idx, bin_factor, out_file, min_value, max_value)\n</code></pre> <p>Process a Z-block of images by averaging along the Z axis, downsampling in XY, converting to 8-bit, and writing to disk.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(file_list)","title":"<code>file_list</code>","text":"(<code>list</code>)           \u2013            <p>List of file paths (entire volume stack).</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for XY downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(out_file)","title":"<code>out_file</code>","text":"(<code>Path</code>)           \u2013            <p>Output file path for the downsampled image.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(min_value)","title":"<code>min_value</code>","text":"(<code>float</code>)           \u2013            <p>Minimum intensity for 8-bit scaling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(max_value)","title":"<code>max_value</code>","text":"(<code>float</code>)           \u2013            <p>Maximum intensity for 8-bit scaling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block","title":"process_vector_block","text":"<pre><code>process_vector_block(block: list[Path], bin_factor: int, h: int, w: int, output_dir: Path, idx: int) -&gt; None\n</code></pre> <p>Processes a single block of numpy files and saves the downsampled output.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(block)","title":"<code>block</code>","text":"(<code>List[Path]</code>)           \u2013            <p>List of file paths to the numpy files in the block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(h)","title":"<code>h</code>","text":"(<code>int</code>)           \u2013            <p>Height of the data block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(w)","title":"<code>w</code>","text":"(<code>int</code>)           \u2013            <p>Width of the data block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(idx)","title":"<code>idx</code>","text":"(<code>int</code>)           \u2013            <p>Index of the current block.</p>"},{"location":"reference/api/#cardiotensor.utils.plot_vector_field","title":"plot_vector_field","text":"<p>Functions:</p> <ul> <li> <code>plot_vector_field_with_fury</code>             \u2013              <p>Visualize a 3D vector field using FURY with optional HA-based coloring.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.plot_vector_field.plot_vector_field_with_fury","title":"plot_vector_field_with_fury","text":"<pre><code>plot_vector_field_with_fury(vector_field, size_arrow=1, ha_volume=None, stride=10, voxel_size=1.0, save_path=None)\n</code></pre> <p>Visualize a 3D vector field using FURY with optional HA-based coloring.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.plot_vector_field.plot_vector_field_with_fury(vector_field)","title":"<code>vector_field</code>","text":"(<code>ndarray</code>)           \u2013            <p>4D array (Z, Y, X, 3) of vectors.</p>"},{"location":"reference/api/#cardiotensor.utils.plot_vector_field.plot_vector_field_with_fury(ha_volume)","title":"<code>ha_volume</code>","text":"(<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>3D array (Z, Y, X) of helix angles in degrees.</p>"},{"location":"reference/api/#cardiotensor.utils.plot_vector_field.plot_vector_field_with_fury(stride)","title":"<code>stride</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Downsampling stride to reduce number of vectors.</p>"},{"location":"reference/api/#cardiotensor.utils.plot_vector_field.plot_vector_field_with_fury(voxel_size)","title":"<code>voxel_size</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Physical voxel size for proper arrow scaling.</p>"},{"location":"reference/api/#cardiotensor.utils.plot_vector_field.plot_vector_field_with_fury(save_path)","title":"<code>save_path</code>","text":"(<code>Path</code>, default:                   <code>None</code> )           \u2013            <p>If provided, save the image to this path.</p>"},{"location":"reference/api/#cardiotensor.utils.utils","title":"utils","text":"<p>Functions:</p> <ul> <li> <code>convert_to_8bit</code>             \u2013              <p>Converts a NumPy array to an 8-bit image.</p> </li> <li> <code>read_conf_file</code>             \u2013              <p>Reads and parses a configuration file into a dictionary.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit","title":"convert_to_8bit","text":"<pre><code>convert_to_8bit(img: ndarray, perc_min: int = 0, perc_max: int = 100, min_value: float | None = None, max_value: float | None = None) -&gt; ndarray\n</code></pre> <p>Converts a NumPy array to an 8-bit image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: 8-bit converted image.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(img)","title":"<code>img</code>","text":"(<code>ndarray</code>)           \u2013            <p>Input image array.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(perc_min)","title":"<code>perc_min</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Minimum percentile for normalization. Default is 0.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(perc_max)","title":"<code>perc_max</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>Maximum percentile for normalization. Default is 100.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(min_value)","title":"<code>min_value</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Optional explicit minimum value.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(max_value)","title":"<code>max_value</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Optional explicit maximum value.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.read_conf_file","title":"read_conf_file","text":"<pre><code>read_conf_file(file_path: str) -&gt; dict[str, Any]\n</code></pre> <p>Reads and parses a configuration file into a dictionary.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Parsed configuration parameters.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the configuration file does not exist.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If expected numerical or array values are incorrectly formatted.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.utils.read_conf_file(file_path)","title":"<code>file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/cli/","title":"Commands","text":"<p>Cardiotensor provides powerful features for analyzing 3D cardiac imaging data, from processing imaging volumes and calculating orientation to managing large-scale projects with support for multiple configurations and platforms.</p>"},{"location":"reference/cli/#orientation-computation","title":"Orientation Computation","text":"<p>Compute myocyte orientation from a 3D volume using a configuration file.</p> <ul> <li><code>cardio-tensor</code>   Computes structure tensor, helix/transverse angle, FA, and eigenvectors.</li> </ul> <p>See the example to get started.</p>"},{"location":"reference/cli/#transmural-analysis","title":"Transmural Analysis","text":"<p>Plot angle profiles across the heart wall using an interactive GUI.</p> <ul> <li><code>cardio-analysis</code>   Define transmural lines, adjust sampling, and export results.</li> </ul> <p>See the example for details.</p>"},{"location":"reference/cli/#3d-visualization","title":"3D Visualization","text":"<p>Visualize results in 3D using vector fields and streamlines.</p> <ul> <li> <p><code>cardio-visualize-vector</code>   Render vector fields using Fury. Optionally export to ParaView (VTK format).</p> </li> <li> <p><code>cardio-generate-streamlines</code>   Generate streamlines from the vector field. Outputs <code>.npz</code> files compatible with Amira.</p> </li> <li> <p><code>cardio-visualize-streamlines</code>   Visualize streamlines in 3D using Fury. Can also export to ParaView.</p> </li> </ul> <p>See the example for usage.</p>"},{"location":"reference/cli/#next-steps","title":"Next Steps","text":"<p>Read the example for an introduction to each feature.</p>"},{"location":"reference/configuration/","title":"Configuration File","text":"<p>The configuration file in cardiotensor allows you to specify the parameters required for processing input datasets, calculating orientation tensors, computing angles, and saving results. Below is a detailed explanation of each section and parameter in the configuration file.</p>"},{"location":"reference/configuration/#example-configuration-file","title":"Example Configuration File","text":"<p>This is an example of a configuration file as found in the <code>examples/</code> directory.</p> <pre><code>[DATASET]\n# Path to the folder containing the input images (accepted formats: .tif, .jp2, .mhd)\nIMAGES_PATH = ./data/635.2um_LADAF-2021-17_heart_overview_\n\n# Voxel size of the input images in micrometers (\u00b5m).\nVOXEL_SIZE = 635.2\n\n# Path to the folder containing the segmentation mask (accepted formats: .tif or .jp2)\n# If no mask is available, leave this field empty.\nMASK_PATH = ./data/mask\n\n\n[STRUCTURE TENSOR CALCULATION]\n# Gradient scale (sigma) used for smoothing before gradient calculation.\n# This Gaussian filter reduces noise while preserving important edges.\nSIGMA = 0.4\n\n# Integration scale (rho) used for smoothing the products of gradients.\n# A larger value results in smoother, more coherent orientation fields by integrating over a larger neighborhood.\nRHO = 0.6\n\n# Multiple of RHO at which the gradients are truncated.\n# A larger value requires a larger margin around the image, set in VERTICAL_PADDING.\nTRUNCATE = 4\n\n# Padding to avoid border artifacts\n# Default value is TRUNCATE * RHO + 0.5\n# VERTICAL_PADDING = 10\n\n# Number of slices to load into memory at a time during processing.\n# This affects memory usage and processing speed. Adjust based on system capacity.\nN_CHUNK = 20\n\n# Enable GPU computation during the structure tensor calculation (True/False)\nUSE_GPU = True\n\n# Whether to save the orientation vectors (as .npy) (True/False)\n# Use for 3D vector/fiber visualisation\nWRITE_VECTORS = True\n\n# Specify the processing direction:\n#   - True: Process slices from the beginning (0) to the end.\n#   - False: Process slices from the end to the beginning.\nREVERSE = False\n\n\n[ANGLE CALCULATION]\n# Whether to save the helical and intrusion angles and fractional anisotropy (True/False)\nWRITE_ANGLES = True\n\n# Coordinates of points along the left ventricle axis.\n# The first point should be coordinates of the mitral valve point in the volume ([X, Y, Z])\n# The last point should be coordinates of the apex point in the volume ([X, Y, Z])\n# Intermediate points will be interpolated to create a curved centre line.\nAXIS_POINTS = [104,110,116], [41,87,210], [68,95,162]\n\n\n[TEST]\n# Enable test mode:\n#   - True: Process and plot only a single slice for testing.\n#   - False: Perform the full processing on the entire volume.\nTEST = True\n\n# Specify the slice number to process when test mode is enabled.\nN_SLICE_TEST = 155\n\n\n[OUTPUT]\n# Path to the folder where the results will be saved\nOUTPUT_PATH =./output\n\n# Output file format for the results (e.g., jp2 or tif).\n# Default format is jp2\nOUTPUT_FORMAT = tif\n\n# Type of pixel values in the output file:\n#   - \"8bit\" for grayscale 8-bit images\n#   - \"rgb\" for 3-channel color images\nOUTPUT_TYPE = 8bit\n</code></pre> <p>Note</p> <p>Modify the configuration file as needed to fit your dataset.</p>"},{"location":"reference/configuration/#explanation-of-parameters","title":"Explanation of Parameters","text":""},{"location":"reference/configuration/#dataset","title":"<code>[DATASET]</code>","text":"<ul> <li><code>IMAGES_PATH</code>: Path to the input dataset containing 3D images.</li> <li><code>VOXEL_SIZE</code>: Voxel size of the dataset in micrometers.</li> <li><code>MASK_PATH</code>: Path to the binary segmentation mask. Leave blank if no mask is available.</li> </ul> <p>Note</p> <p>The mask volume can be downscaled compared to the heart volume. The binning factor will be estimated automatically and the mask will be upscaled accordingly.</p>"},{"location":"reference/configuration/#structure-tensor-calculation","title":"<code>[STRUCTURE TENSOR CALCULATION]</code>","text":"<ul> <li><code>SIGMA</code>: Noise scale before gradient computation. Helps reduce noise while preserving structures.</li> <li><code>RHO</code>: Integration scale for smoothing tensor components. Larger values yield smoother orientation fields.</li> <li><code>TRUNCATE</code>: Multiple of RHO for defining the gradient filter kernel size.</li> <li><code>VERTICAL_PADDING (optional)</code>: Extra padding (in voxels) to avoid edge artifacts. If not set, defaults to TRUNCATE * RHO + 0.5.</li> <li><code>N_CHUNK</code>: Number of slices to process simultaneously.</li> <li><code>USE_GPU</code>: Enable GPU computation (requires CuPy).</li> <li><code>WRITE_VECTORS</code>: Save orientation 3rd vector as <code>.npy</code> files.</li> </ul> <p>Warning</p> <p>Orientation vectors are saved in <code>float32</code> format and may consume significant disk space.</p> <ul> <li><code>REVERSE</code>: Process volume from end to start if set to <code>True</code>.</li> </ul> <p>Note</p> <p>The structure tensor calculation is performed using the <code>structure-tensor</code> Python package with optional CUDA support.</p>"},{"location":"reference/configuration/#angle-calculation","title":"<code>[ANGLE CALCULATION]</code>","text":"<ul> <li><code>WRITE_ANGLES</code>: Save helix and intrusion angles and fractional anisotropy values.</li> <li><code>AXIS_POINTS</code>: List of 3D points <code>[X, Y, Z]</code> along the ventricle axis. Typically, the first and last points correspond to the mitral valve and apex. Intermediate points help create a curved axis via interpolation.</li> </ul>"},{"location":"reference/configuration/#test","title":"<code>[TEST]</code>","text":"<ul> <li><code>TEST</code>: Enable test mode to process a single slice.</li> <li><code>N_SLICE_TEST</code>: Index of the slice to test.</li> </ul> <p>Note</p> <p>Use test mode to verify processing on a small subset before running on the full volume.</p>"},{"location":"reference/configuration/#output","title":"<code>[OUTPUT]</code>","text":"<ul> <li><code>OUTPUT_PATH</code>: Directory where results are saved.</li> <li><code>OUTPUT_FORMAT</code>: Output format (<code>jp2</code> or <code>tif</code>).</li> <li><code>OUTPUT_TYPE</code>: Image bit depth and channel type:<ul> <li><code>8bit</code>: grayscale 8-bit image.</li> <li><code>rgb</code>: 3-channel color image.</li> </ul> </li> </ul>"}]}