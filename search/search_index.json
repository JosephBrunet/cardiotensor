{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"Cardiotensor <p>A Python package for calculating 3D cardiomyocyte orientations in heart images.</p> <p> </p> <p> Helical angle map of a heart scanned using synchrtron X-ray imaging. </p>"},{"location":"#introduction","title":"Introduction","text":"<p>Cardiotensor is a user-friendly and memory-efficient toolkit designed for analyzing the orientation of cardiomyocyte fibers in large heart imaging datasets. It uses advanced image processing techniques to help researchers to accurately quantify 3D cardiomyocyte orientations with high efficiency.</p>"},{"location":"#installation","title":"Installation","text":"<p>Clone the repository and install the package using pip:</p> <pre><code>git clone https://github.com/JosephBrunet/cardiotensor.git\ncd cardiotensor\npip install .\n</code></pre> <p>\u26a0\ufe0f Require python 3.10 or newer</p>"},{"location":"#documentation","title":"Documentation","text":"<p>cardiotensor's documentation is available at josephbrunet.fr/cardiotensor/</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Have a look at our simple example that runs you through all the commands of the package</p>"},{"location":"#more-information","title":"More Information","text":"<p>This package uses the structure-tensor package to calculate the structure tensor, extending its capabilities for cardiac imaging.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! If you encounter a bug or have suggestions for new features:</p> <ul> <li>Report an Issue: Open an issue in the repository.</li> <li>Submit a Pull Request: Fork the repository, make changes, and submit a pull request.</li> </ul> <p>For major changes, please discuss them in an issue first.</p>"},{"location":"#contact","title":"Contact","text":"<p>For questions, feedback, or support, please contact the maintainers at [j.brunet@ucl.ac.uk].</p>"},{"location":"#reference","title":"Reference","text":"<p>Brunet, J., Cook, A. C., Walsh, C. L., Cranley, J., Tafforeau, P., Engel, K., Arthurs, O., Berruyer, C., Burke O\u2019Leary, E., Bellier, A., et al. (2024). Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography. Radiology, 312(1), e232731. https://doi.org/10.1148/radiol.232731. [PDF]</p> <pre><code>@article{brunet2024multidimensional,\n  title={Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography},\n  author={Brunet, Joseph and Cook, Andrew C and Walsh, Claire L and Cranley, James and Tafforeau, Paul and Engel, Klaus and Arthurs, Owen and Berruyer, Camille and Burke O\u2019Leary, Emer and Bellier, Alexandre and others},\n  journal={Radiology},\n  volume={312},\n  number={1},\n  pages={e232731},\n  year={2024},\n  publisher={Radiological Society of North America}\n}\n</code></pre>"},{"location":"citing/","title":"Citing","text":"<p>If you use <code>cardiotensor</code> in your research, please cite the related paper as follow:</p>"},{"location":"citing/#apa-format","title":"APA Format","text":"<p>Brunet, J., Cook, A. C., Walsh, C. L., Cranley, J., Tafforeau, P., Engel, K., Arthurs, O., Berruyer, C., Burke O\u2019Leary, E., Bellier, A., et al. (2024). Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography. Radiology, 312(1), e232731. https://doi.org/10.1148/radiol.232731</p>"},{"location":"citing/#bibtex-format","title":"BibTeX Format","text":"<p>For LaTeX users, please include the following BibTeX entry to reference <code>cardiotensor</code>:</p> <pre><code>@article{brunet2024multidimensional,\n  title={Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography},\n  author={Brunet, Joseph and Cook, Andrew C and Walsh, Claire L and Cranley, James and Tafforeau, Paul and Engel, Klaus and Arthurs, Owen and Berruyer, Camille and Burke O\u2019Leary, Emer and Bellier, Alexandre and others},\n  journal={Radiology},\n  volume={312},\n  number={1},\n  pages={e232731},\n  year={2024},\n  publisher={Radiological Society of North America}\n}\n</code></pre>"},{"location":"citing/#citation-examples-in-various-formats","title":"Citation Examples in Various Formats","text":"<ol> <li> <p>MLA Format    Brunet, Joseph, et al. \"Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography.\" Radiology, vol. 312, no. 1, 2024, p. e232731.</p> </li> <li> <p>Chicago Style    Brunet, Joseph, Andrew C. Cook, Claire L. Walsh, James Cranley, Paul Tafforeau, Klaus Engel, Owen Arthurs, Camille Berruyer, Emer Burke O\u2019Leary, Alexandre Bellier, et al. 2024. \"Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography.\" Radiology 312 (1): e232731.</p> </li> <li> <p>Harvard Format    Brunet, J., Cook, A.C., Walsh, C.L., Cranley, J., Tafforeau, P., Engel, K., Arthurs, O., Berruyer, C., Burke O\u2019Leary, E., Bellier, A., et al., 2024. Multidimensional analysis of the adult human heart in health and disease using hierarchical phase-contrast tomography. Radiology, 312(1), p.e232731.</p> </li> </ol>"},{"location":"citing/#why-cite-cardiotensor","title":"Why Cite <code>cardiotensor</code>?","text":"<p>Citing <code>cardiotensor</code> in your research helps other researchers to discover and reference the software, support continued development, and acknowledges the work invested in creating this package. Proper citations also contribute to the visibility and impact of the <code>cardiotensor</code> project.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for considering contributing to the cardiotensor project! We welcome contributions of all kinds, including bug fixes, feature suggestions, documentation improvements, and more. Follow the guidelines below to ensure a smooth contribution process.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li> <p>Fork the Repository</p> <ul> <li>Go to the GitHub repository and click the \"Fork\" button.</li> <li>Clone your fork locally:     <pre><code>git clone https://github.com/&lt;your-username&gt;/cardiotensor.git\ncd cardiotensor\n</code></pre></li> </ul> </li> <li> <p>Create a Branch</p> <ul> <li>Create a new branch for your feature or bug fix:     <pre><code>git checkout -b my-feature-branch\n</code></pre></li> </ul> </li> <li> <p>Install Dependencies</p> <ul> <li>Ensure you have all required dependencies installed. You can use the provided development dependencies:     <pre><code>pip install -e .[dev]\n</code></pre></li> </ul> </li> <li> <p>Make Your Changes</p> <ul> <li>Make your changes to the codebase, documentation, or both.</li> <li>Follow PEP8 standards for Python code.</li> </ul> </li> <li> <p>Run Tests</p> <ul> <li>Ensure all tests pass and that your contribution does not introduce any issues:     <pre><code>pytest\n</code></pre></li> <li>If you add new features, include corresponding tests.</li> </ul> </li> <li> <p>Commit Your Changes</p> <ul> <li>Write clear and concise commit messages:     <pre><code>git add .\ngit commit -m \"Add feature: XYZ\"\n</code></pre></li> </ul> </li> <li> <p>Push and Create a Pull Request</p> <ul> <li>Push your branch to your fork:     <pre><code>git push origin my-feature-branch\n</code></pre></li> <li>Go to the original repository and create a Pull Request (PR).</li> <li>Provide a clear description of your changes and why they are necessary.</li> </ul> </li> </ol>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<p>To maintain a consistent and readable codebase, please adhere to the following guidelines:</p> <ul> <li>PEP 8: Follow PEP8 coding style standards for Python code.</li> <li>Type Annotations: Include type hints for function arguments and return values.</li> <li>Docstrings: Provide clear docstrings for functions and classes. We recommend using the Google docstring style.</li> </ul>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<ul> <li>Be Respectful: Treat all contributors with respect and professionalism.</li> <li>Follow Standards: Ensure your contributions align with the project's coding and documentation standards.</li> <li>Keep It Simple: Focus on making the project easier to use and maintain.</li> <li>Documentation: Update documentation if your changes affect the usage or functionality of the project.</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you encounter a bug or have a suggestion, please open an issue. Include as much detail as possible:</p> <ul> <li>Steps to reproduce the issue.</li> <li>Expected and actual results.</li> <li>Your environment (e.g., Python version, OS).</li> </ul>"},{"location":"contributing/#contact","title":"Contact","text":"<p>For questions or further assistance, feel free to reach out to the project maintainers via the repository's Discussions or email listed in the repository.</p> <p>We appreciate your contributions and support in making cardiotensor better!</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>To help you get started with cardiotensor, we'll cover a few important topics:</p> <ul> <li>Installing cardiotensor</li> <li>First steps after installation</li> <li>A simple example</li> </ul> <p>Read on, or jump ahead to another section:</p> <ul> <li>Use the reference documentation to find details about something specific.</li> </ul>"},{"location":"getting-started/examples/","title":"Example","text":"<p>This example demonstrates how to use the cardiotensor package with the example provided in the repository. This example will help you understand how to process input data, compute fiber orientations, and visualize results.</p>"},{"location":"getting-started/examples/#example-directory-overview","title":"Example Directory Overview","text":"<p>The <code>./examples/</code> directory contains:</p> <ul> <li>Datasets: Cropped 3D volumes and binary masks for testing and experimentation.</li> <li>Configuration File: A pre-filled <code>parameters_example.conf</code> file for running the workflows.</li> </ul>"},{"location":"getting-started/examples/#data","title":"Data","text":"<ol> <li> <p>Heart Volume:</p> <ul> <li>Path: <code>./data/635.2um_LADAF-2021-17_heart_overview_/</code></li> <li>Description: A downsampled 3D heart image volume designed for testing. The full-resolution dataset is available at the Human Organ Atlas.</li> </ul> </li> <li> <p>Binary Mask:</p> <ul> <li>Path: <code>./data/mask/</code></li> <li>Description: A binary mask used for segmenting the heart from the background.</li> </ul> </li> </ol>"},{"location":"getting-started/examples/#running-the-examples","title":"Running the Examples","text":""},{"location":"getting-started/examples/#installation","title":"Installation","text":"<ol> <li> <p>Clone the repository and install the package:     <pre><code>$ git clone https://github.com/JosephBrunet/cardiotensor.git\n$ cd cardiotensor\n$ pip install .\n</code></pre></p> </li> <li> <p>Navigate to the <code>examples</code> directory:     <pre><code>$ cd examples\n</code></pre></p> </li> </ol>"},{"location":"getting-started/examples/#processing-a-test-slice","title":"Processing a Test Slice","text":"<ol> <li>Open <code>parameters_example.conf</code> and set <code>TEST = True</code> in the <code>[TEST]</code> section.</li> </ol> <p>Note</p> <p>For information about conf file see the section Configuration file</p> <ol> <li>Run the following command:     <pre><code>$ cardio-tensor ./parameters_example.conf\n</code></pre></li> <li>The output will be displayed as a plot for a single slice:</li> </ol> Image caption"},{"location":"getting-started/examples/#processing-the-entire-volume","title":"Processing the Entire Volume","text":"<ol> <li>Set <code>TEST = False</code> in <code>parameters_example.conf</code>.</li> </ol> <p>Note</p> <p>For information about conf file see the section Configuration file</p> <ol> <li>Run the command:     <pre><code>$ cardio-tensor ./parameters_example.conf\n</code></pre></li> <li>Outputs will be saved in the <code>./output</code> directory with the following structure:     <pre><code>./output\n\u251c\u2500\u2500 HA   # Helix angle results\n\u251c\u2500\u2500 IA   # Intrusion angle results\n\u2514\u2500\u2500 FA   # Fractional anisotropy results\n</code></pre></li> </ol>"},{"location":"getting-started/examples/#visualizing-transmural-profiles","title":"Visualizing Transmural Profiles","text":"<ol> <li> <p>Use the <code>cardio-analysis</code> command:     <pre><code>$ cardio-analysis ./parameters_example.conf 150\n</code></pre>     Replace <code>150</code> with the slice number you wish to analyze.</p> </li> <li> <p>The GUI will appear, allowing you to:</p> <ul> <li>Define a transmural profile line.</li> <li>Adjust parameters like <code>Angle range</code> and <code>Number of lines</code>.</li> <li>Plot and export the profile.  </li> </ul> <p>The generated profile will resemble:  </p> </li> <li> <p>The provided dataset is for demonstration purposes only.</p> </li> <li>Modify parameters in <code>parameters_example.conf</code> (e.g., <code>SIGMA</code>, <code>RHO</code>) to suit your data.</li> </ol>"},{"location":"getting-started/examples/#notes","title":"Notes","text":""},{"location":"getting-started/first-steps/","title":"Verify the installation","text":"<p>After installing cardiotensor, you can verify that cardiotensor is installed correctly by running the command:</p> <pre><code>$ cardio-tensor --help\nusage: cardio-tensor [-h] [--start_index START_INDEX]\n                  [--end_index END_INDEX] [--gpu]\n                  [conf_file_path]\n\nThis script computes orientation for a 3D volume based on the provided configuration file.\n\n...\n</code></pre> <p>You should see a help menu listing the available commands.</p> <p>If no errors occur, the installation is successful. You can then check out our simple example to get familiar with the commands of cardiotensor</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Cardiotensor is a powerful and user-friendly toolkit for analyzing the orientation of cardiomyocites fibers in the heart</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> </ul>"},{"location":"getting-started/installation/#installing-with-pip-recommended","title":"Installing with pip recommended","text":"<p>cardiotensor is published as a Python package and can be installed with <code>pip</code>, ideally by using a virtual environment. Open up a terminal and install cardiotensor with:</p> <pre><code>pip install cardiotensor\n</code></pre>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from Source","text":"<p>To install cardiotensor from source, follow these steps:</p> <ol> <li> <p>Clone the repository from GitHub:</p> <pre><code>$ git clone https://github.com/JosephBrunet/cardiotensor.git\n</code></pre> </li> <li> <p>Navigate to the cloned repository directory:</p> <pre><code>$ cd cardiotensor\n</code></pre> </li> <li> <p>Install the package using pip:</p> <pre><code>$ pip install -e .  # (1)!\n</code></pre> <ol> <li>The <code>-e</code> flag in <code>pip install -e .</code> installs the package in editable mode, allowing changes to the source code to be immediately reflected without reinstallation.</li> </ol> </li> </ol>"},{"location":"getting-started/installation/#uninstallation","title":"Uninstallation","text":"<p>If you need to remove cardiotensor from your system, follow these steps:</p> <pre><code>$ pip uninstall cardio-tensor\n</code></pre> <p>This should remove cardiotensor from your environment.</p>"},{"location":"reference/","title":"Reference","text":"<p>The reference section provides information about specific parts of cardiotensor:</p> <ul> <li>Commands: A reference for cardiotensor's command line interface.</li> <li>Configuration file: A reference for cardiotensor's configuration file.</li> <li>API: A reference for cardiotensor's modules and functions.</li> </ul>"},{"location":"reference/api/","title":"API","text":""},{"location":"reference/api/#cardiotensor","title":"cardiotensor","text":"<p>Modules:</p> <ul> <li> <code>analysis</code>           \u2013            </li> <li> <code>export</code>           \u2013            </li> <li> <code>launcher</code>           \u2013            </li> <li> <code>orientation</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis","title":"analysis","text":"<p>Modules:</p> <ul> <li> <code>analysis_functions</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions","title":"analysis_functions","text":"<p>Functions:</p> <ul> <li> <code>calculate_intensities</code>             \u2013              <p>Calculate intensity profiles along multiple lines.</p> </li> <li> <code>find_end_points</code>             \u2013              <p>Find the end points for lines at different angles within a range.</p> </li> <li> <code>plot_intensity</code>             \u2013              <p>Plot intensity profiles with mean and percentile shading.</p> </li> <li> <code>save_intensity</code>             \u2013              <p>Save intensity profiles to a CSV file.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.calculate_intensities","title":"calculate_intensities","text":"<pre><code>calculate_intensities(img_helix: ndarray, start_point: tuple[int, int], end_point: tuple[int, int], angle_range: float = 5, N_line: int = 10, max_value: float | None = None, min_value: float | None = None) -&gt; list[ndarray]\n</code></pre> <p>Calculate intensity profiles along multiple lines.</p> <p>Parameters: img_helix (np.ndarray): The image array. start_point (Tuple[int, int]): The starting point of the line. end_point (Tuple[int, int]): The ending point of the line. angle_range (float, optional): The range of angles to consider in degrees. Default is 5. N_line (int, optional): The number of lines to generate. Default is 10. max_value (Optional[float], optional): Maximum value for intensity normalization. Default is None. min_value (Optional[float], optional): Minimum value for intensity normalization. Default is None.</p> <p>Returns: List[np.ndarray]: List of intensity profiles for each line.</p>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.find_end_points","title":"find_end_points","text":"<pre><code>find_end_points(start_point: tuple[float, float], end_point: tuple[float, float], angle_range: float, N_line: int) -&gt; ndarray\n</code></pre> <p>Find the end points for lines at different angles within a range.</p> <p>Parameters: start_point (Tuple[int, int]): The starting point of the main line. end_point (Tuple[int, int]): The ending point of the main line. angle_range (float): The range of angles to consider in degrees. N_line (int): The number of lines to generate within the range.</p> <p>Returns: np.ndarray: Array of end points for the generated lines.</p>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.plot_intensity","title":"plot_intensity","text":"<pre><code>plot_intensity(intensity_profiles: list[ndarray], label_y: str = '', x_max_lim: float | None = None, x_min_lim: float | None = None, y_max_lim: float | None = None, y_min_lim: float | None = None) -&gt; None\n</code></pre> <p>Plot intensity profiles with mean and percentile shading.</p> <p>Parameters: intensity_profiles (List[np.ndarray]): List of intensity profiles. label_y (str, optional): Label for the y-axis. Default is an empty string. x_max_lim (Optional[float], optional): Maximum x-axis limit. Default is None. x_min_lim (Optional[float], optional): Minimum x-axis limit. Default is None. y_max_lim (Optional[float], optional): Maximum y-axis limit. Default is None. y_min_lim (Optional[float], optional): Minimum y-axis limit. Default is None.</p>"},{"location":"reference/api/#cardiotensor.analysis.analysis_functions.save_intensity","title":"save_intensity","text":"<pre><code>save_intensity(intensity_profiles: list[ndarray], save_path: str) -&gt; None\n</code></pre> <p>Save intensity profiles to a CSV file.</p> <p>Parameters: intensity_profiles (List[np.ndarray]): List of intensity profiles. save_path (str): Path to save the CSV file.</p> <p>Returns: None</p>"},{"location":"reference/api/#cardiotensor.export","title":"export","text":"<p>Modules:</p> <ul> <li> <code>amira_writer</code>           \u2013            </li> <li> <code>vtk_writer</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.export.amira_writer","title":"amira_writer","text":"<p>Functions:</p> <ul> <li> <code>amira_writer</code>             \u2013              <p>Processes a 3D vector field and generates an AmiraMesh (.am) file.</p> </li> <li> <code>angle_between_vectors</code>             \u2013              <p>Calculates the element-wise angle between two vector fields.</p> </li> <li> <code>find_consecutive_points</code>             \u2013              <p>Finds consecutive points in the direction specified by the vector field.</p> </li> <li> <code>scale_points</code>             \u2013              <p>Scales each coordinate in a list of points by the specified pixel size.</p> </li> <li> <code>write_am_file</code>             \u2013              <p>Writes an .am file with start and end vertices for each element in <code>consecutive_points_list</code>.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer","title":"amira_writer","text":"<pre><code>amira_writer(conf_file_path: str, start_index: int | None = None, end_index: int | None = None, bin_factor: int | None = None, num_ini_points: int = 20000, num_steps: int = 1000000, segment_length: float = 20.0, angle_threshold: float = 60.0, segment_min_length_threshold: int = 10) -&gt; None\n</code></pre> <p>Processes a 3D vector field and generates an AmiraMesh (.am) file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer(conf_file_path)","title":"<code>conf_file_path</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer(start_index)","title":"<code>start_index</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Starting index for processing. Defaults to 0.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer(end_index)","title":"<code>end_index</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Ending index for processing. Defaults to the end of the volume.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Downsampling factor. If specified, downsampling will be applied.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer(num_ini_points)","title":"<code>num_ini_points</code>","text":"(<code>int</code>, default:                   <code>20000</code> )           \u2013            <p>Number of initial random points to sample. Defaults to 20000.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer(num_steps)","title":"<code>num_steps</code>","text":"(<code>int</code>, default:                   <code>1000000</code> )           \u2013            <p>Maximum number of steps for tracing each vector. Defaults to 1000000.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer(segment_length)","title":"<code>segment_length</code>","text":"(<code>float</code>, default:                   <code>20.0</code> )           \u2013            <p>Length of each segment along the vector direction. Defaults to 20.0.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer(angle_threshold)","title":"<code>angle_threshold</code>","text":"(<code>float</code>, default:                   <code>60.0</code> )           \u2013            <p>Maximum allowable angle between consecutive vectors. Defaults to 60.0.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.amira_writer(segment_min_length_threshold)","title":"<code>segment_min_length_threshold</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Minimum length of segments to retain. Defaults to 30.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.angle_between_vectors","title":"angle_between_vectors","text":"<pre><code>angle_between_vectors(vec1: ndarray, vec2: ndarray) -&gt; ndarray\n</code></pre> <p>Calculates the element-wise angle between two vector fields.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Array of angles (degrees) with shape (z, y, x).</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.export.amira_writer.angle_between_vectors(vec1)","title":"<code>vec1</code>","text":"(<code>ndarray</code>)           \u2013            <p>First vector field with shape (3, z, y, x).</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.angle_between_vectors(vec2)","title":"<code>vec2</code>","text":"(<code>ndarray</code>)           \u2013            <p>Second vector field with shape (3, z, y, x).</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.find_consecutive_points","title":"find_consecutive_points","text":"<pre><code>find_consecutive_points(start_point: tuple[int, int, int], vector_field: ndarray, num_steps: int = 4, segment_length: float = 10, angle_threshold: float = 60) -&gt; list[tuple]\n</code></pre> <p>Finds consecutive points in the direction specified by the vector field.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[tuple]</code>           \u2013            <p>List[Tuple[float, float, float]]: List of consecutive points.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.export.amira_writer.find_consecutive_points(start_point)","title":"<code>start_point</code>","text":"(<code>Tuple[int, int, int]</code>)           \u2013            <p>Starting point (z, y, x).</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.find_consecutive_points(vector_field)","title":"<code>vector_field</code>","text":"(<code>ndarray</code>)           \u2013            <p>Vector field of shape (3, Z, Y, X).</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.find_consecutive_points(num_steps)","title":"<code>num_steps</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of steps to take in the vector direction.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.find_consecutive_points(segment_length)","title":"<code>segment_length</code>","text":"(<code>float</code>, default:                   <code>10</code> )           \u2013            <p>Length of each segment.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.find_consecutive_points(angle_threshold)","title":"<code>angle_threshold</code>","text":"(<code>float</code>, default:                   <code>60</code> )           \u2013            <p>Threshold to stop when angle deviation exceeds.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.scale_points","title":"scale_points","text":"<pre><code>scale_points(consecutive_points: list[list[tuple[float, float, float]]], pixel_size: float) -&gt; list[list[tuple[float, float, float]]]\n</code></pre> <p>Scales each coordinate in a list of points by the specified pixel size.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[tuple[float, float, float]]]</code>           \u2013            <p>List[List[Tuple[float, float, float]]]: A new list with each point's coordinates scaled by pixel_size.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.export.amira_writer.scale_points(consecutive_points)","title":"<code>consecutive_points</code>","text":"(<code>List[List[Tuple[float, float, float]]]</code>)           \u2013            <p>Nested list where each sublist contains tuples representing points (x, y, z).</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.scale_points(pixel_size)","title":"<code>pixel_size</code>","text":"(<code>float</code>)           \u2013            <p>The scaling factor for each coordinate (e.g., pixel size in micrometers).</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.write_am_file","title":"write_am_file","text":"<pre><code>write_am_file(consecutive_points_list: list[list[tuple[float, float, float]]], HA_angle: list[float], z_angle: list[float], file_path: str = 'output.am') -&gt; None\n</code></pre> <p>Writes an .am file with start and end vertices for each element in <code>consecutive_points_list</code>.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.write_am_file(consecutive_points_list)","title":"<code>consecutive_points_list</code>","text":"(<code>List[List[Tuple[float, float, float]]]</code>)           \u2013            <p>Nested list containing points (x, y, z).</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.write_am_file(HA_angle)","title":"<code>HA_angle</code>","text":"(<code>List[float]</code>)           \u2013            <p>List of helix angles for each point.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.write_am_file(z_angle)","title":"<code>z_angle</code>","text":"(<code>List[float]</code>)           \u2013            <p>List of z-axis angles for each point.</p>"},{"location":"reference/api/#cardiotensor.export.amira_writer.write_am_file(file_path)","title":"<code>file_path</code>","text":"(<code>str</code>, default:                   <code>'output.am'</code> )           \u2013            <p>Path to the output file. Defaults to \"output.am\".</p>"},{"location":"reference/api/#cardiotensor.export.vtk_writer","title":"vtk_writer","text":"<p>Functions:</p> <ul> <li> <code>vtk_writer</code>             \u2013              <p>Process volume data and write results to a VTK file.</p> </li> <li> <code>writeStructuredVTK</code>             \u2013              <p>Write a plain text regular grid VTK file from 3D or 4D arrays.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.vtk_writer","title":"vtk_writer","text":"<pre><code>vtk_writer(conf_file_path: str, bin_factor: int = 1, start_index: int | None = None, end_index: int | None = None) -&gt; None\n</code></pre> <p>Process volume data and write results to a VTK file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.vtk_writer(conf_file_path)","title":"<code>conf_file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.vtk_writer(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Binning factor for data reduction. Default is 1.</p>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.vtk_writer(start_index)","title":"<code>start_index</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Starting index for processing. Default is None.</p>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.vtk_writer(end_index)","title":"<code>end_index</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Ending index for processing. Default is None.</p>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.writeStructuredVTK","title":"writeStructuredVTK","text":"<pre><code>writeStructuredVTK(aspectRatio: list[float] = [1.0, 1.0, 1.0], origin: list[float] = [0.0, 0.0, 0.0], cellData: dict[str, ndarray] = {}, pointData: dict[str, ndarray] = {}, fileName: str = 'spam.vtk') -&gt; None\n</code></pre> <p>Write a plain text regular grid VTK file from 3D or 4D arrays.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.writeStructuredVTK(aspectRatio)","title":"<code>aspectRatio</code>","text":"(<code>list[float]</code>, default:                   <code>[1.0, 1.0, 1.0]</code> )           \u2013            <p>Length between two nodes in every direction. Default is [1.0, 1.0, 1.0].</p>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.writeStructuredVTK(origin)","title":"<code>origin</code>","text":"(<code>list[float]</code>, default:                   <code>[0.0, 0.0, 0.0]</code> )           \u2013            <p>Origin of the grid. Default is [0.0, 0.0, 0.0].</p>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.writeStructuredVTK(cellData)","title":"<code>cellData</code>","text":"(<code>dict[str, ndarray]</code>, default:                   <code>{}</code> )           \u2013            <p>Cell fields; 3D arrays for scalar fields, 4D arrays for vector fields.</p>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.writeStructuredVTK(pointData)","title":"<code>pointData</code>","text":"(<code>dict[str, ndarray]</code>, default:                   <code>{}</code> )           \u2013            <p>Nodal fields interpolated by Paraview.</p>"},{"location":"reference/api/#cardiotensor.export.vtk_writer.writeStructuredVTK(fileName)","title":"<code>fileName</code>","text":"(<code>str</code>, default:                   <code>'spam.vtk'</code> )           \u2013            <p>Name of the output file. Default is 'spam.vtk'.</p>"},{"location":"reference/api/#cardiotensor.launcher","title":"launcher","text":"<p>Modules:</p> <ul> <li> <code>slurm_launcher</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher","title":"slurm_launcher","text":"<p>Functions:</p> <ul> <li> <code>monitor_job_output</code>             \u2013              <p>Monitor the output directory until all images are processed.</p> </li> <li> <code>slurm_launcher</code>             \u2013              <p>Launch Slurm jobs for 3D data processing.</p> </li> <li> <code>submit_job_to_slurm</code>             \u2013              <p>Submit a Slurm job and return its job ID.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.monitor_job_output","title":"monitor_job_output","text":"<pre><code>monitor_job_output(output_directory: str, total_images: int, file_extension: str) -&gt; None\n</code></pre> <p>Monitor the output directory until all images are processed.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.monitor_job_output(output_directory)","title":"<code>output_directory</code>","text":"(<code>str</code>)           \u2013            <p>Path to the directory to monitor.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.monitor_job_output(total_images)","title":"<code>total_images</code>","text":"(<code>int</code>)           \u2013            <p>Total number of expected images.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.monitor_job_output(file_extension)","title":"<code>file_extension</code>","text":"(<code>str</code>)           \u2013            <p>File extension to monitor for.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.slurm_launcher","title":"slurm_launcher","text":"<pre><code>slurm_launcher(conf_file_path: str) -&gt; None\n</code></pre> <p>Launch Slurm jobs for 3D data processing.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.slurm_launcher(conf_file_path)","title":"<code>conf_file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm","title":"submit_job_to_slurm","text":"<pre><code>submit_job_to_slurm(executable_path: str, conf_file_path: str, start_image: int, end_image: int, N_chunk: int = 10, mem_needed: int = 64) -&gt; int\n</code></pre> <p>Submit a Slurm job and return its job ID.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The Slurm job ID.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(executable_path)","title":"<code>executable_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the executable script.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(conf_file_path)","title":"<code>conf_file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(start_image)","title":"<code>start_image</code>","text":"(<code>int</code>)           \u2013            <p>Index of the first image to process.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(end_image)","title":"<code>end_image</code>","text":"(<code>int</code>)           \u2013            <p>Index of the last image to process.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(N_chunk)","title":"<code>N_chunk</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of chunks for the job. Default is 10.</p>"},{"location":"reference/api/#cardiotensor.launcher.slurm_launcher.submit_job_to_slurm(mem_needed)","title":"<code>mem_needed</code>","text":"(<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Memory required in GB. Default is 64.</p>"},{"location":"reference/api/#cardiotensor.orientation","title":"orientation","text":"<p>Modules:</p> <ul> <li> <code>orientation_computation_functions</code>           \u2013            </li> <li> <code>orientation_computation_pipeline</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions","title":"orientation_computation_functions","text":"<p>Functions:</p> <ul> <li> <code>adjust_start_end_index</code>             \u2013              <p>Adjusts start and end indices for image processing, considering padding and test mode.</p> </li> <li> <code>calculate_center_vector</code>             \u2013              <p>Compute the linear regression vector for a given set of 3D points.</p> </li> <li> <code>calculate_structure_tensor</code>             \u2013              <p>Calculates the structure tensor of a volume.</p> </li> <li> <code>compute_fraction_anisotropy</code>             \u2013              <p>Computes Fractional Anisotropy (FA) from eigenvalues of a structure tensor.</p> </li> <li> <code>compute_helix_and_transverse_angles</code>             \u2013              <p>Computes helix and transverse angles from a 2D vector field.</p> </li> <li> <code>interpolate_points</code>             \u2013              <p>Generates interpolated points using cubic spline interpolation for a given set of 3D points.</p> </li> <li> <code>plot_images</code>             \u2013              <p>Plots images of the heart with helix, intrusion, and FA annotations.</p> </li> <li> <code>remove_padding</code>             \u2013              <p>Removes padding from the volume, eigenvalues, and eigenvectors.</p> </li> <li> <code>rotate_vectors_to_new_axis</code>             \u2013              <p>Rotates a vector field slice to align with a new axis.</p> </li> <li> <code>write_images</code>             \u2013              <p>Writes processed images to the specified directory.</p> </li> <li> <code>write_vector_field</code>             \u2013              <p>Saves a vector field slice to the specified directory in .npy format.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index","title":"adjust_start_end_index","text":"<pre><code>adjust_start_end_index(start_index: int, end_index: int, N_img: int, padding_start: int, padding_end: int, is_test: bool, n_slice: int) -&gt; tuple[int, int]\n</code></pre> <p>Adjusts start and end indices for image processing, considering padding and test mode.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>Tuple[int, int]: Adjusted start and end indices.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>The initial start index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(end_index)","title":"<code>end_index</code>","text":"(<code>int</code>)           \u2013            <p>The initial end index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(N_img)","title":"<code>N_img</code>","text":"(<code>int</code>)           \u2013            <p>Number of images in the volume data.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(padding_start)","title":"<code>padding_start</code>","text":"(<code>int</code>)           \u2013            <p>Padding to add at the start.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(padding_end)","title":"<code>padding_end</code>","text":"(<code>int</code>)           \u2013            <p>Padding to add at the end.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(is_test)","title":"<code>is_test</code>","text":"(<code>bool</code>)           \u2013            <p>Flag indicating whether in test mode.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.adjust_start_end_index(n_slice)","title":"<code>n_slice</code>","text":"(<code>int</code>)           \u2013            <p>Test slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_center_vector","title":"calculate_center_vector","text":"<pre><code>calculate_center_vector(points: ndarray) -&gt; ndarray\n</code></pre> <p>Compute the linear regression vector for a given set of 3D points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: A single 3D unit vector representing the direction of the best-fit line.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_center_vector(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An Nx3 array of (x, y, z) coordinates representing the curved line.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor","title":"calculate_structure_tensor","text":"<pre><code>calculate_structure_tensor(volume: ndarray, SIGMA: float, RHO: float, TRUNCATE: float = 4.0, devices: list[str] | None = None, block_size: int = 200, use_gpu: bool = False, dtype: type = float32) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Calculates the structure tensor of a volume.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: Structure tensor, eigenvalues, and eigenvectors.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The 3D volume data.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(SIGMA)","title":"<code>SIGMA</code>","text":"(<code>float</code>)           \u2013            <p>Sigma value for Gaussian smoothing.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(RHO)","title":"<code>RHO</code>","text":"(<code>float</code>)           \u2013            <p>Rho value for Gaussian smoothing.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(devices)","title":"<code>devices</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>List of devices for parallel processing (e.g., ['cpu', 'cuda:0']).</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(block_size)","title":"<code>block_size</code>","text":"(<code>int</code>, default:                   <code>200</code> )           \u2013            <p>Size of the blocks for processing. Default is 200.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.calculate_structure_tensor(use_gpu)","title":"<code>use_gpu</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, uses GPU for calculations. Default is False.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_fraction_anisotropy","title":"compute_fraction_anisotropy","text":"<pre><code>compute_fraction_anisotropy(eigenvalues_2d: ndarray) -&gt; ndarray\n</code></pre> <p>Computes Fractional Anisotropy (FA) from eigenvalues of a structure tensor.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Fractional Anisotropy values.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_fraction_anisotropy(eigenvalues_2d)","title":"<code>eigenvalues_2d</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D array of eigenvalues (l1, l2, l3).</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_helix_and_transverse_angles","title":"compute_helix_and_transverse_angles","text":"<pre><code>compute_helix_and_transverse_angles(vector_field_2d: ndarray, center_point: tuple[int, int, int]) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Computes helix and transverse angles from a 2D vector field.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>Tuple[np.ndarray, np.ndarray]: Helix and transverse angle arrays.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_helix_and_transverse_angles(vector_field_2d)","title":"<code>vector_field_2d</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D orientation vector field.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.compute_helix_and_transverse_angles(center_point)","title":"<code>center_point</code>","text":"(<code>Tuple[int, int, int]</code>)           \u2013            <p>Coordinates of the center point.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.interpolate_points","title":"interpolate_points","text":"<pre><code>interpolate_points(points: list[tuple[float, float, float]], N_img: int) -&gt; ndarray\n</code></pre> <p>Generates interpolated points using cubic spline interpolation for a given set of 3D points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Array of interpolated points.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.interpolate_points(points)","title":"<code>points</code>","text":"(<code>list[tuple[float, float, float]]</code>)           \u2013            <p>A list of (x, y, z) points.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.interpolate_points(N_img)","title":"<code>N_img</code>","text":"(<code>int</code>)           \u2013            <p>The number of slices in the z-dimension.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images","title":"plot_images","text":"<pre><code>plot_images(img: ndarray, img_helix: ndarray, img_intrusion: ndarray, img_FA: ndarray, center_point: tuple[int, int, int]) -&gt; None\n</code></pre> <p>Plots images of the heart with helix, intrusion, and FA annotations.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(img)","title":"<code>img</code>","text":"(<code>ndarray</code>)           \u2013            <p>Grayscale image of the heart.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(img_helix)","title":"<code>img_helix</code>","text":"(<code>ndarray</code>)           \u2013            <p>Helix angle image.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(img_intrusion)","title":"<code>img_intrusion</code>","text":"(<code>ndarray</code>)           \u2013            <p>Intrusion angle image.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(img_FA)","title":"<code>img_FA</code>","text":"(<code>ndarray</code>)           \u2013            <p>Fractional Anisotropy (FA) image.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.plot_images(center_point)","title":"<code>center_point</code>","text":"(<code>Tuple[int, int, int]</code>)           \u2013            <p>Coordinates of the center point.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding","title":"remove_padding","text":"<pre><code>remove_padding(volume: ndarray, val: ndarray, vec: ndarray, padding_start: int, padding_end: int) -&gt; tuple[ndarray, ndarray, ndarray]\n</code></pre> <p>Removes padding from the volume, eigenvalues, and eigenvectors.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray, ndarray]</code>           \u2013            <p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Adjusted data without padding.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The 3D volume data.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(val)","title":"<code>val</code>","text":"(<code>ndarray</code>)           \u2013            <p>The eigenvalues.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(vec)","title":"<code>vec</code>","text":"(<code>ndarray</code>)           \u2013            <p>The eigenvectors.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(padding_start)","title":"<code>padding_start</code>","text":"(<code>int</code>)           \u2013            <p>Padding at the start to remove.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.remove_padding(padding_end)","title":"<code>padding_end</code>","text":"(<code>int</code>)           \u2013            <p>Padding at the end to remove.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.rotate_vectors_to_new_axis","title":"rotate_vectors_to_new_axis","text":"<pre><code>rotate_vectors_to_new_axis(vector_field_slice: ndarray, new_axis_vec: ndarray) -&gt; ndarray\n</code></pre> <p>Rotates a vector field slice to align with a new axis.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Rotated vectors aligned with the new axis.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.rotate_vectors_to_new_axis(vector_field_slice)","title":"<code>vector_field_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of vectors to rotate.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.rotate_vectors_to_new_axis(new_axis_vec)","title":"<code>new_axis_vec</code>","text":"(<code>ndarray</code>)           \u2013            <p>The new axis to align vectors with.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images","title":"write_images","text":"<pre><code>write_images(img_helix: ndarray, img_intrusion: ndarray, img_FA: ndarray, start_index: int, OUTPUT_DIR: str, OUTPUT_FORMAT: str, OUTPUT_TYPE: str, z: int) -&gt; None\n</code></pre> <p>Writes processed images to the specified directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(img_helix)","title":"<code>img_helix</code>","text":"(<code>ndarray</code>)           \u2013            <p>Image data for helix angles.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(img_intrusion)","title":"<code>img_intrusion</code>","text":"(<code>ndarray</code>)           \u2013            <p>Image data for intrusion angles.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(img_FA)","title":"<code>img_FA</code>","text":"(<code>ndarray</code>)           \u2013            <p>Image data for fractional anisotropy.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>Starting index for filenames.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(OUTPUT_DIR)","title":"<code>OUTPUT_DIR</code>","text":"(<code>str</code>)           \u2013            <p>Directory to save the images.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(OUTPUT_FORMAT)","title":"<code>OUTPUT_FORMAT</code>","text":"(<code>str</code>)           \u2013            <p>Format of the output files ('tif' or 'jp2').</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(OUTPUT_TYPE)","title":"<code>OUTPUT_TYPE</code>","text":"(<code>str</code>)           \u2013            <p>Type of output ('8bit' or 'rgb').</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_images(z)","title":"<code>z</code>","text":"(<code>int</code>)           \u2013            <p>Current slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field","title":"write_vector_field","text":"<pre><code>write_vector_field(vector_field_slice: ndarray, start_index: int, output_dir: str, slice_idx: int) -&gt; None\n</code></pre> <p>Saves a vector field slice to the specified directory in .npy format.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(vector_field_slice)","title":"<code>vector_field_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Vector field data slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>Starting index for filenames.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(output_dir)","title":"<code>output_dir</code>","text":"(<code>str</code>)           \u2013            <p>Directory to save the vector field.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_functions.write_vector_field(slice_idx)","title":"<code>slice_idx</code>","text":"(<code>int</code>)           \u2013            <p>Current slice index.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline","title":"orientation_computation_pipeline","text":"<p>Functions:</p> <ul> <li> <code>compute_orientation</code>             \u2013              <p>Compute the orientation for a volume dataset based on the configuration.</p> </li> <li> <code>compute_slice_angles_and_anisotropy</code>             \u2013              <p>Compute helix angles, transverse angles, and fractional anisotropy for a slice.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation","title":"compute_orientation","text":"<pre><code>compute_orientation(conf_file_path: str, start_index: int = 0, end_index: int | None = None, use_gpu: bool = False) -&gt; None\n</code></pre> <p>Compute the orientation for a volume dataset based on the configuration.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(conf_file_path)","title":"<code>conf_file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Start index for processing. Default is 0.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(end_index)","title":"<code>end_index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>End index for processing. Default is None.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_orientation(use_gpu)","title":"<code>use_gpu</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use GPU for calculations. Default is False.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy","title":"compute_slice_angles_and_anisotropy","text":"<pre><code>compute_slice_angles_and_anisotropy(z: int, vector_field_slice: ndarray, img_slice: ndarray, center_point: ndarray, eigen_val_slice: ndarray, center_line: ndarray, OUTPUT_DIR: str, OUTPUT_FORMAT: str, OUTPUT_TYPE: str, start_index: int, WRITE_VECTORS: bool, WRITE_ANGLES: bool, IS_TEST: bool) -&gt; None\n</code></pre> <p>Compute helix angles, transverse angles, and fractional anisotropy for a slice.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(z)","title":"<code>z</code>","text":"(<code>int</code>)           \u2013            <p>Index of the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(vector_field_slice)","title":"<code>vector_field_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Vector field for the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(img_slice)","title":"<code>img_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Image data for the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(center_point)","title":"<code>center_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>Center point for alignment.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(eigen_val_slice)","title":"<code>eigen_val_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>Eigenvalues for the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(center_line)","title":"<code>center_line</code>","text":"(<code>ndarray</code>)           \u2013            <p>Center line for alignment.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(OUTPUT_DIR)","title":"<code>OUTPUT_DIR</code>","text":"(<code>str</code>)           \u2013            <p>Directory to save the output.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(OUTPUT_FORMAT)","title":"<code>OUTPUT_FORMAT</code>","text":"(<code>str</code>)           \u2013            <p>Format for the output files (e.g., \"tif\").</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(OUTPUT_TYPE)","title":"<code>OUTPUT_TYPE</code>","text":"(<code>str</code>)           \u2013            <p>Type of output (e.g., \"8bits\", \"rgb\").</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>)           \u2013            <p>Start index of the slice.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(WRITE_VECTORS)","title":"<code>WRITE_VECTORS</code>","text":"(<code>bool</code>)           \u2013            <p>Whether to output vector fields.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(WRITE_ANGLES)","title":"<code>WRITE_ANGLES</code>","text":"(<code>bool</code>)           \u2013            <p>Whether to output angles and fractional anisotropy.</p>"},{"location":"reference/api/#cardiotensor.orientation.orientation_computation_pipeline.compute_slice_angles_and_anisotropy(IS_TEST)","title":"<code>IS_TEST</code>","text":"(<code>bool</code>)           \u2013            <p>Whether in test mode.</p>"},{"location":"reference/api/#cardiotensor.utils","title":"utils","text":"<p>Modules:</p> <ul> <li> <code>DataReader</code>           \u2013            </li> <li> <code>downsampling</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader","title":"DataReader","text":"<p>Classes:</p> <ul> <li> <code>DataReader</code>           \u2013            </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader","title":"DataReader","text":"<pre><code>DataReader(path: str | Path)\n</code></pre> <p>Initializes the DataReader with a path to the volume.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>load_volume</code>             \u2013              <p>Loads the volume data based on the detected volume type.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>Path to the volume directory or file.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume","title":"load_volume","text":"<pre><code>load_volume(start_index: int = 0, end_index: int | None = None, unbinned_shape: tuple[int, int, int] | None = None) -&gt; ndarray\n</code></pre> <p>Loads the volume data based on the detected volume type.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Loaded (and possibly resized) volume data.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Start index for slicing (for stacks).</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume(end_index)","title":"<code>end_index</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>End index for slicing (for stacks). If None, loads the entire stack.</p>"},{"location":"reference/api/#cardiotensor.utils.DataReader.DataReader.load_volume(unbinned_shape)","title":"<code>unbinned_shape</code>","text":"(<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>Shape of the volume without downsampling. Default is None (no binning).</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling","title":"downsampling","text":"<p>Functions:</p> <ul> <li> <code>downsample_vector_volume</code>             \u2013              <p>Downsamples a vector volume using multiprocessing.</p> </li> <li> <code>downsample_volume</code>             \u2013              <p>Downsamples a volume of images using multiprocessing.</p> </li> <li> <code>process_image_block</code>             \u2013              <p>Processes a single block of image files and saves the downsampled output.</p> </li> <li> <code>process_vector_block</code>             \u2013              <p>Processes a single block of numpy files and saves the downsampled output.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume","title":"downsample_vector_volume","text":"<pre><code>downsample_vector_volume(input_npy: Path, bin_factor: int, output_dir: Path) -&gt; None\n</code></pre> <p>Downsamples a vector volume using multiprocessing.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume(input_npy)","title":"<code>input_npy</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the directory containing numpy files.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_vector_volume(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume","title":"downsample_volume","text":"<pre><code>downsample_volume(input_path: Path, bin_factor: int, output_dir: Path, file_format: str) -&gt; None\n</code></pre> <p>Downsamples a volume of images using multiprocessing.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(input_path)","title":"<code>input_path</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the directory containing image files.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.downsample_volume(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block","title":"process_image_block","text":"<pre><code>process_image_block(block: list[Path], bin_factor: int, h: int, w: int, output_dir: Path, idx: int) -&gt; None\n</code></pre> <p>Processes a single block of image files and saves the downsampled output.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(block)","title":"<code>block</code>","text":"(<code>List[Path]</code>)           \u2013            <p>List of file paths to the image files in the block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(h)","title":"<code>h</code>","text":"(<code>int</code>)           \u2013            <p>Height of the data block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(w)","title":"<code>w</code>","text":"(<code>int</code>)           \u2013            <p>Width of the data block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_image_block(idx)","title":"<code>idx</code>","text":"(<code>int</code>)           \u2013            <p>Index of the current block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block","title":"process_vector_block","text":"<pre><code>process_vector_block(block: list[Path], bin_factor: int, h: int, w: int, output_dir: Path, idx: int) -&gt; None\n</code></pre> <p>Processes a single block of numpy files and saves the downsampled output.</p> <p>Parameters:</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(block)","title":"<code>block</code>","text":"(<code>List[Path]</code>)           \u2013            <p>List of file paths to the numpy files in the block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(bin_factor)","title":"<code>bin_factor</code>","text":"(<code>int</code>)           \u2013            <p>Binning factor for downsampling.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(h)","title":"<code>h</code>","text":"(<code>int</code>)           \u2013            <p>Height of the data block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(w)","title":"<code>w</code>","text":"(<code>int</code>)           \u2013            <p>Width of the data block.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(output_dir)","title":"<code>output_dir</code>","text":"(<code>Path</code>)           \u2013            <p>Path to the output directory.</p>"},{"location":"reference/api/#cardiotensor.utils.downsampling.process_vector_block(idx)","title":"<code>idx</code>","text":"(<code>int</code>)           \u2013            <p>Index of the current block.</p>"},{"location":"reference/api/#cardiotensor.utils.utils","title":"utils","text":"<p>Functions:</p> <ul> <li> <code>convert_to_8bit</code>             \u2013              <p>Converts a NumPy array to an 8-bit image.</p> </li> <li> <code>read_conf_file</code>             \u2013              <p>Reads and parses a configuration file into a dictionary.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit","title":"convert_to_8bit","text":"<pre><code>convert_to_8bit(img: ndarray, perc_min: int = 0, perc_max: int = 100, min_value: float | None = None, max_value: float | None = None) -&gt; ndarray\n</code></pre> <p>Converts a NumPy array to an 8-bit image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: 8-bit converted image.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(img)","title":"<code>img</code>","text":"(<code>ndarray</code>)           \u2013            <p>Input image array.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(perc_min)","title":"<code>perc_min</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Minimum percentile for normalization. Default is 0.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(perc_max)","title":"<code>perc_max</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>Maximum percentile for normalization. Default is 100.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(min_value)","title":"<code>min_value</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Optional explicit minimum value.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.convert_to_8bit(max_value)","title":"<code>max_value</code>","text":"(<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Optional explicit maximum value.</p>"},{"location":"reference/api/#cardiotensor.utils.utils.read_conf_file","title":"read_conf_file","text":"<pre><code>read_conf_file(file_path: str) -&gt; dict[str, Any]\n</code></pre> <p>Reads and parses a configuration file into a dictionary.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Parsed configuration parameters.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the configuration file does not exist.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If expected numerical or array values are incorrectly formatted.</p> </li> </ul>"},{"location":"reference/api/#cardiotensor.utils.utils.read_conf_file(file_path)","title":"<code>file_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the configuration file.</p>"},{"location":"reference/cli/","title":"Commands","text":"<p>Cardiotensor provides powerful features for analyzing 3D cardiac imaging data, from processing imaging volumes and calculating orientation to managing large-scale projects with support for multiple configurations and platforms.</p>"},{"location":"reference/cli/#orientation-computation","title":"Orientation Computation","text":"<p>Compute myocytes orientation for a volume using a specified configuration file.</p> <ul> <li><code>cardio-tensor</code></li> </ul> <p>See the example to get started.</p>"},{"location":"reference/cli/#transmural-analysis","title":"Transmural Analysis","text":"<p>GUI to plot angle profiles across the heart.</p> <ul> <li><code>cardio-analysis</code></li> </ul> <p>See the example on how to visualize transmural profile to get started.</p>"},{"location":"reference/cli/#3d-visualization-with-export","title":"3D Visualization with Export","text":"<p>Visualize results in 3D by exporting vectors to Amira or Paraview:</p> <ul> <li><code>cardio-amira</code>: Export to Amira</li> <li><code>cardio-vtk</code>: Export to Paraview</li> </ul> <p>Warning</p> <p>Still under testing.</p>"},{"location":"reference/cli/#next-steps","title":"Next steps","text":"<p>Read the example for an introduction to each feature.</p>"},{"location":"reference/configuration/","title":"Configuration File","text":"<p>The configuration file in cardiotensor allows you to specify the parameters required for processing input datasets, calculating orientation tensors, computing angles, and saving results. Below is a detailed explanation of each section and parameter in the configuration file.</p>"},{"location":"reference/configuration/#example-configuration-file","title":"Example Configuration File","text":"<p>This is an example of a configuration file as found in the <code>examples/</code> directory.</p> <pre><code>[DATASET]\n# Path to the folder containing the input images (accepted formats: .tif, .jp2, .mhd)\nIMAGES_PATH = ./data/635.2um_LADAF-2021-17_heart_overview_\n# Voxel size of the input images in micrometers (\u00b5m).\nVOXEL_SIZE = 635.2\n# Path to the folder containing the segmentation mask (accepted formats: .tif or .jp2)\n# If no mask is available, leave this field empty.\nMASK_PATH = ./data/mask\n\n\n[STRUCTURE TENSOR CALCULATION]\n# Gradient scale (sigma) used for smoothing before gradient calculation.\n# This Gaussian filter reduces noise while preserving important edges.\nSIGMA = 1\n# Integration scale (rho) used for smoothing the products of gradients.\n# A larger value results in smoother, more coherent orientation fields by integrating over a larger neighborhood.\nRHO = 2\n# Number of slices to load into memory at a time during processing.\n# This affects memory usage and processing speed. Adjust based on system capacity.\nN_CHUNK = 20\n# Enable GPU computation during the structure tensor calculation (True/False)\nUSE_GPU = True\n# Whether to save the orientation vectors (as .npy) (True/False)\n# Use for 3D vector/fiber visualisation\nWRITE_VECTORS = False\n# Specify the processing direction:\n#   - True: Process slices from the beginning (0) to the end.\n#   - False: Process slices from the end to the beginning.\nREVERSE = False\n\n\n[ANGLE CALCULATION]\n# Whether to save the helical and intrusion angles and fractional anisotropy (True/False)\nWRITE_ANGLES = True\n# Coordinates of points along the left ventricle axis. \n# The first point should be coordinates of the mitral valve point in the volume ([X, Y, Z]) \n# The last point should be coordinates of the apex point in the volume ([X, Y, Z])\n# Intermediate points will be interpolated to create a curved centre line.\nAXIS_POINTS = [104,110,116], [41,87,210], [68,95,162]\n\n\n[TEST]\n# Enable test mode:\n#   - True: Process and plot only a single slice for testing.\n#   - False: Perform the full processing on the entire volume.\nTEST = True\n# Specify the slice number to process when test mode is enabled.\nN_SLICE_TEST = 155\n\n\n[OUTPUT]\n# Path to the folder where the results will be saved\nOUTPUT_PATH =./output\n# Output file format for the results (e.g., jp2 or tif).\n# Default format is jp2\nOUTPUT_FORMAT = tif\n# Type of pixel values in the output file:\n#   - \"8bit\" for grayscale 8-bit images\n#   - \"rgb\" for 3-channel color images\nOUTPUT_TYPE = 8bit\n</code></pre> <p>Note</p> <p>Modify the configuration file as needed to fit your dataset.</p>"},{"location":"reference/configuration/#explanation-of-parameters","title":"Explanation of Parameters","text":""},{"location":"reference/configuration/#dataset","title":"<code>[DATASET]</code>","text":"<ul> <li><code>IMAGES_PATH</code>: Path to the input dataset containing 3D images.</li> <li><code>VOXEL_SIZE</code>: Voxel size of the dataset in micrometers.</li> <li><code>MASK_PATH</code>: Path to the binary segmentation mask. Leave blank if no mask is available.</li> </ul> <p>Note</p> <p>The mask volume can be downscaled compared to the heart volume. The binning factor will be estimated automatically and the mask will be upscaled accordingly.</p>"},{"location":"reference/configuration/#structure-tensor-calculation","title":"<code>[STRUCTURE TENSOR CALCULATION]</code>","text":"<ul> <li><code>SIGMA</code>: Noise scale before gradient computation. Helps reduce noise while preserving structures.</li> <li><code>RHO</code>: Integration scale for smoothing tensor components. Larger values yield smoother orientation fields.</li> <li><code>N_CHUNK</code>: Number of slices to process simultaneously.</li> <li><code>USE_GPU</code>: Enable GPU computation (requires CuPy).</li> <li><code>WRITE_VECTORS</code>: Save orientation 3rd vector as <code>.npy</code> files.</li> </ul> <p>Warning</p> <p>Orientation vectors are saved in <code>float32</code> format and may consume significant disk space.</p> <ul> <li><code>REVERSE</code>: Process volume from end to start if set to <code>True</code>.</li> </ul> <p>Note</p> <p>The structure tensor calculation is performed using the <code>structure-tensor</code> Python package with optional CUDA support.</p>"},{"location":"reference/configuration/#angle-calculation","title":"<code>[ANGLE CALCULATION]</code>","text":"<ul> <li><code>WRITE_ANGLES</code>: Save helix and intrusion angles and fractional anisotropy values.</li> <li><code>AXIS_POINTS</code>: List of 3D points <code>[X, Y, Z]</code> along the ventricle axis. Typically, the first and last points correspond to the mitral valve and apex. Intermediate points help create a curved axis via interpolation.</li> </ul>"},{"location":"reference/configuration/#test","title":"<code>[TEST]</code>","text":"<ul> <li><code>TEST</code>: Enable test mode to process a single slice.</li> <li><code>N_SLICE_TEST</code>: Index of the slice to test.</li> </ul> <p>Note</p> <p>Use test mode to verify processing on a small subset before running on the full volume.</p>"},{"location":"reference/configuration/#output","title":"<code>[OUTPUT]</code>","text":"<ul> <li><code>OUTPUT_PATH</code>: Directory where results are saved.</li> <li><code>OUTPUT_FORMAT</code>: Output format (<code>jp2</code> or <code>tif</code>).</li> <li><code>OUTPUT_TYPE</code>: Image bit depth and channel type:<ul> <li><code>8bit</code>: grayscale 8-bit image.</li> <li><code>rgb</code>: 3-channel color image.</li> </ul> </li> </ul>"}]}